<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="There&#39;s no place like 127.0.0.1">
<meta property="og:type" content="website">
<meta property="og:title" content="Lqsss&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lqsss&#39;s Blog">
<meta property="og:description" content="There&#39;s no place like 127.0.0.1">
<meta property="article:author" content="lqsss">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>

  <title>Lqsss's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lqsss's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(9)%E2%80%94%E2%80%94Netty%E8%A7%A3%E7%A0%81%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(9)%E2%80%94%E2%80%94Netty%E8%A7%A3%E7%A0%81%E5%99%A8/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(9)——Netty解码器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据不同的协议来进行数据流到对象的转换，decoder是网络编程中不可或缺的一个步骤。Netty有一个<code>ByteToMessageDecoder</code>抽象解码器，上层应用实现该类的<code>decode()</code>方法。</p>
<h3 id="解码步骤"><a href="#解码步骤" class="headerlink" title="解码步骤"></a>解码步骤</h3><ol>
<li>通过Cumulator积累字节流数据</li>
<li>执行实现ByteToMessageDecoder子类的方法来解析对象</li>
<li>将解析的ByteBuf对象向下传播</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><code>ByteToMessageDecoder</code>抽象类实现了<code>ChannelInboundHandlerAdapter</code>，加入到pipeline中，channelRead作为入口进行解码操作。</p>
<p><code>channelRead(ChannelHandlerContext ctx, Object msg)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf data = (ByteBuf) msg;</span><br><span class="line">            first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">          	<span class="comment">//第一次就是当前收到的data</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                cumulation = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1. 累加器进行字节流的累加</span></span><br><span class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 执行实现ByteToMessageDecoder子类的方法来解析对象</span></span><br><span class="line">            callDecode(ctx, cumulation, out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cumulation != <span class="keyword">null</span> &amp;&amp; !cumulation.isReadable()) &#123;</span><br><span class="line">                numReads = <span class="number">0</span>;</span><br><span class="line">                cumulation.release();</span><br><span class="line">                cumulation = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (++ numReads &gt;= discardAfterReads) &#123;</span><br><span class="line">                <span class="comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4275</span></span><br><span class="line">                numReads = <span class="number">0</span>;</span><br><span class="line">                discardSomeReadBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = out.size();</span><br><span class="line">            decodeWasNull = !out.insertSinceRecycled();</span><br><span class="line">            <span class="comment">//3. 将解析的ByteBuf对象向下传播</span></span><br><span class="line">            fireChannelRead(ctx, out, size);</span><br><span class="line">            out.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>累加器进行字节流的累加</li>
</ol>
<p>默认累加器实现<code>ByteToMessageDecoder#MERGE_CUMULATOR</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ByteBuf buffer;</span><br><span class="line">            <span class="comment">//1.1 超出累加器的容量</span></span><br><span class="line">            <span class="keyword">if</span> (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</span><br><span class="line">                || cumulation.refCnt() &gt; <span class="number">1</span> || cumulation.isReadOnly()) &#123;</span><br><span class="line">                <span class="comment">// Expand cumulation (by replace it) when either there is not more room in the buffer</span></span><br><span class="line">                <span class="comment">// or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</span></span><br><span class="line">                <span class="comment">// duplicate().retain() or if its read-only.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See:</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line">                <span class="comment">//扩容</span></span><br><span class="line">                buffer = expandCumulation(alloc, cumulation, in.readableBytes());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer = cumulation;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            buffer.writeBytes(in);</span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw</span></span><br><span class="line">            <span class="comment">// for whatever release (for example because of OutOfMemoryError)</span></span><br><span class="line">            in.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>执行实现ByteToMessageDecoder子类的方法来解析对象</li>
</ol>
<p><code>callDecode(ctx, cumulation, out)</code></p>
<ul>
<li>ctx：上下文</li>
<li>in：这次接收到的数据</li>
<li>out：得到的字节数据转成功的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//外层是循环</span></span><br><span class="line">        <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">            <span class="comment">//先mark一下的对象的数量</span></span><br><span class="line">            <span class="keyword">int</span> outSize = out.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果存在已生成的对象</span></span><br><span class="line">            <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//传递到下文</span></span><br><span class="line">                fireChannelRead(ctx, out, outSize);</span><br><span class="line">                <span class="comment">//清理该list</span></span><br><span class="line">                out.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if this handler was removed before continuing with decoding.</span></span><br><span class="line">                <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See:</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/4635</span></span><br><span class="line">                <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                outSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//mark一下当前数据的可读字节</span></span><br><span class="line">            <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line">            <span class="comment">//调用子类实现的decode，将in的字节数据解码成对象到out里</span></span><br><span class="line">            decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if this handler was removed before continuing the loop.</span></span><br><span class="line">            <span class="comment">// If it was removed, it is not safe to continue to operate on the buffer.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/1664</span></span><br><span class="line">            <span class="keyword">if</span> (ctx.isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//经过解码后，没有新生成的对象</span></span><br><span class="line">            <span class="keyword">if</span> (outSize == out.size()) &#123;</span><br><span class="line">                <span class="comment">//而且in的字节流也没有被消耗，说明这一次无法</span></span><br><span class="line">                <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//可能被消耗了部分，需要后面几次继续解码才能形成一个对象</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有消耗任何数据就解码出了对象，有问题</span></span><br><span class="line">            <span class="keyword">if</span> (oldInputLength == in.readableBytes()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(</span><br><span class="line">                    StringUtil.simpleClassName(getClass()) +</span><br><span class="line">                    <span class="string">".decode() did not read anything but decoded a message."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是进行单次解码方法调用，直接break</span></span><br><span class="line">            <span class="keyword">if</span> (isSingleDecode()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception cause) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>将解析的ByteBuf对象向下传播</li>
</ol>
<p><code>fireChannelRead(ctx, out, size);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fireChannelRead</span><span class="params">(ChannelHandlerContext ctx, CodecOutputList msgs, <span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i ++) &#123;</span><br><span class="line">            ctx.fireChannelRead(msgs.getUnsafe(i));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(8)%E2%80%94%E2%80%94Netty%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E6%B1%A0-Recyler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(8)%E2%80%94%E2%80%94Netty%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%AF%B9%E8%B1%A1%E6%B1%A0-Recyler/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(8)——Netty轻量级对象池-Recyler</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Recyler的使用"><a href="#Recyler的使用" class="headerlink" title="Recyler的使用"></a>Recyler的使用</h2><h2 id="为什么要使用Recyler"><a href="#为什么要使用Recyler" class="headerlink" title="为什么要使用Recyler"></a>为什么要使用Recyler</h2><p>在对象池里直接复用之前已经创建好的对象</p>
<ol>
<li>减少内存分配的频率</li>
<li>减少对象的创建与销毁，减少young gc的次数</li>
</ol>
<h2 id="Recyler细节"><a href="#Recyler细节" class="headerlink" title="Recyler细节"></a>Recyler细节</h2><h3 id="Recyler结构"><a href="#Recyler结构" class="headerlink" title="Recyler结构"></a>Recyler结构</h3><ul>
<li><code>threadLocal</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Stack&lt;T&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Stack&lt;T&gt;(Recycler.<span class="keyword">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class="line">                    ratioMask, maxDelayedQueuesPerThread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(Stack&lt;T&gt; value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Let us remove the WeakOrderQueue from the WeakHashMap directly if its safe to remove some overhead</span></span><br><span class="line">            <span class="keyword">if</span> (value.threadRef.get() == Thread.currentThread()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (DELAYED_RECYCLED.isSet()) &#123;</span><br><span class="line">                   DELAYED_RECYCLED.get().remove(value);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>每一个线程都有一个FastThreadLocal的线程变量，存储的数据是Stack<T></p>
<ul>
<li><code>Stack</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack(Recycler&lt;T&gt; parent, Thread thread, <span class="keyword">int</span> maxCapacity, <span class="keyword">int</span> maxSharedCapacityFactor,</span><br><span class="line">              <span class="keyword">int</span> ratioMask, <span class="keyword">int</span> maxDelayedQueues) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            threadRef = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">    <span class="comment">//element的最大容量</span></span><br><span class="line">            <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">    <span class="comment">//该字段表示该线程创建的对象能在其他线程最大缓存对象的数量</span></span><br><span class="line">            availableSharedCapacity = <span class="keyword">new</span> AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));</span><br><span class="line">    <span class="comment">//存储handle</span></span><br><span class="line">            elements = <span class="keyword">new</span> DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];</span><br><span class="line">    <span class="comment">//并不是每次都能把对象回收，回收的比率</span></span><br><span class="line">            <span class="keyword">this</span>.ratioMask = ratioMask;</span><br><span class="line">    <span class="comment">//通过get获取对象，这个对象是由当前thread管理，但是最终在其他线程进行释放，会将该对象放在其他线程里数据结构里(WeakOrderQueue),该字段表示该线程最大缓存对象的数量</span></span><br><span class="line">            <span class="keyword">this</span>.maxDelayedQueues = maxDelayedQueues;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>存储DefaultHandle对象，即可复用对象。内部elment数组，是一个个handle，handle会被外部变量引用</p>
<p>各参数默认值：</p>
<p>maxCapacity：4 * 1024;</p>
<p>maxSharedCapacityFactor：2</p>
<p>ratioMask：7</p>
<p>maxDelayedQueues：默认是2倍cpu核数</p>
<p>availableSharedCapacity：16</p>
<ul>
<li><p>WeakOrderQueue：存储其它线程回收到本线程stack的对象，当某个线程从stack中获取不到对象时，就会从WeakOrderQueue中获取对象</p>
<p>//todo</p>
</li>
</ul>
<h2 id="从Recyler获取对象"><a href="#从Recyler获取对象" class="headerlink" title="从Recyler获取对象"></a>从Recyler获取对象</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>获取当前线程的stack</li>
<li>从stack里面弹出对象</li>
<li>创建对象并绑定Stack</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><code>Recyler#get()</code>:从获取handle对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//maxCapacityPerThread为0，指对象池不再容纳对象</span></span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//直接创建新的对象</span></span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 获取当前线程的stack</span></span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    <span class="comment">//2. 从stack里pop出对象</span></span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1 如果stack里为空，创建handle</span></span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        <span class="comment">//3. 创建新对象并绑定Stack</span></span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NOOP_HANDLE</code>不作任何回收的Handle对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handle NOOP_HANDLE = <span class="keyword">new</span> Handle() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>从stack弹出对象<code>DefaultHandle&lt;T&gt; handle = stack.pop();</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">//当前线程的stack已经没有对象</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1 可能有其他线程在共用该线程的对象</span></span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled multiple times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1 当前线程的stack没有可用的对象复用，其他线程可能有回收过本线程创建的对象</p>
<p><code>scavenge()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavenge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// continue an existing scavenge, if any</span></span><br><span class="line">    <span class="comment">//2.1.1 扫描一些可复用对象的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (scavengeSome()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset our scavenge cursor</span></span><br><span class="line">    <span class="comment">//如果WeakOrderQueue也没有，cursor移到head</span></span><br><span class="line">    prev = <span class="keyword">null</span>;</span><br><span class="line">    cursor = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>scavengeSome()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//2.1.1.1 将该weakQueue的link对象转到该线程stack上</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the thread associated with the queue is gone, unlink it, after</span></span><br><span class="line">            <span class="comment">// performing a volatile read to confirm there is no data left to collect.</span></span><br><span class="line">            <span class="comment">// We never unlink the first queue, as we don't want to synchronize on updating the head.</span></span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cursor = next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1.1.1 将该weakQueue的link对象转到该线程stack上</p>
<p><code>transfer(Stack&lt;?&gt; dst)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(Stack&lt;?&gt; dst)</span> </span>&#123;</span><br><span class="line">        Link head = <span class="keyword">this</span>.head.link;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果当前WeakOrderQueue已经读到最后的link节点了（LINK_CAPACITY为handle数组的极限大小）</span></span><br><span class="line">        <span class="keyword">if</span> (head.readIndex == LINK_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将下一个weakOrderQueue作为当前的head</span></span><br><span class="line">            <span class="keyword">this</span>.head.link = head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     	<span class="comment">//获取head的readIndex</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcStart = head.readIndex;</span><br><span class="line">        <span class="keyword">int</span> srcEnd = head.get();</span><br><span class="line">     </span><br><span class="line">       <span class="comment">//计算出需要转移的数据大小</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> srcSize = srcEnd - srcStart;</span><br><span class="line">        <span class="keyword">if</span> (srcSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     	<span class="comment">//获取待转移目标stack目前的可用偏移量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dstSize = dst.size;</span><br><span class="line">     	<span class="comment">//预期需要的容量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> expectedCapacity = dstSize + srcSize;</span><br><span class="line">			</span><br><span class="line">     	<span class="comment">//超出stack数组的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (expectedCapacity &gt; dst.elements.length) &#123;</span><br><span class="line">            <span class="comment">//最终实际大小：进行左移1位进行扩容</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actualCapacity = dst.increaseCapacity(expectedCapacity);</span><br><span class="line">            <span class="comment">//copy终点</span></span><br><span class="line">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (srcStart != srcEnd) &#123;</span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] srcElems = head.elements;</span><br><span class="line">            <span class="keyword">final</span> DefaultHandle[] dstElems = dst.elements;</span><br><span class="line">            <span class="keyword">int</span> newDstSize = dstSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = srcStart; i &lt; srcEnd; i++) &#123;</span><br><span class="line">                DefaultHandle element = srcElems[i];</span><br><span class="line">                <span class="keyword">if</span> (element.recycleId == <span class="number">0</span>) &#123;</span><br><span class="line">                    element.recycleId = element.lastRecycledId;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.recycleId != element.lastRecycledId) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                srcElems[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dst.dropHandle(element)) &#123;</span><br><span class="line">                    <span class="comment">// Drop the object.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                element.stack = dst;</span><br><span class="line">                dstElems[newDstSize ++] = element;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (srcEnd == LINK_CAPACITY &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Add capacity back as the Link is GCed.</span></span><br><span class="line">                <span class="keyword">this</span>.head.reclaimSpace(LINK_CAPACITY);</span><br><span class="line">                <span class="keyword">this</span>.head.link = head.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head.readIndex = srcEnd;</span><br><span class="line">            <span class="keyword">if</span> (dst.size == newDstSize) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dst.size = newDstSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The destination stack is full already.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>如果stack为空，创建一个默认handle：<code>newHandle()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">newHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultHandle&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>创建新对象并绑定Stack <code>handle.value = newObject(handle);</code></li>
</ol>
<p><code>Recyler#newObject(Handle&lt;T&gt; handle)</code>，实现该接口，将handle与对象绑定，随后被对象的handle进行回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">newObject</span><span class="params">(Handle&lt;T&gt; handle)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h2><h3 id="同线程回收对象"><a href="#同线程回收对象" class="headerlink" title="同线程回收对象"></a>同线程回收对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"object does not belong to handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;?&gt; stack = <span class="keyword">this</span>.stack;</span><br><span class="line">    <span class="keyword">if</span> (lastRecycledId != recycleId || stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回收对象入口：<code>Recycler$Stack#push()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">//判断即将回收的对象是否是当前进行回收的线程创建的</span></span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class="line">        <span class="comment">// The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span></span><br><span class="line">        <span class="comment">//1. 同线程回收入口</span></span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The current Thread is not the one that belongs to the Stack</span></span><br><span class="line">        <span class="comment">// (or the Thread that belonged to the Stack was collected already), we need to signal that the push</span></span><br><span class="line">        <span class="comment">// happens later.</span></span><br><span class="line">        <span class="comment">//2. 回收非本线程的对象</span></span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>同线程回收入口<code>pushNow()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushNow</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次的话肯定为0</span></span><br><span class="line">    <span class="keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//OWN_THREAD_ID 默认值</span></span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="comment">//1.1 大于最大容量或者达到需要drop的比例，并不是回收调所有对象</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        <span class="comment">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="number">1</span>, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[size] = item;</span><br><span class="line">    <span class="keyword">this</span>.size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.1 判断是否drop掉，不进行回收：<code>Stack#dropHandle()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dropHandle</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((++handleRecycleCount &amp; ratioMask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Drop the object.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle.hasBeenRecycled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ratioMask</code>为8，每一次预回收时，handleRecycleCount++，每次进行&amp;运算不等0就丢弃，不进行回收</p>
<h3 id="异线程回收对象"><a href="#异线程回收对象" class="headerlink" title="异线程回收对象"></a>异线程回收对象</h3><ol>
<li>获取WeakOrderQueue</li>
<li>创建WeakOrderQueue</li>
<li>将对象追加到WeakOrderQueue</li>
</ol>
<p><code>pushLater()</code>异线程回收入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// we don't want to have a ref to the queue as the value in our weak map</span></span><br><span class="line">    <span class="comment">// so we null it out; to ensure there are no races with restoring it later</span></span><br><span class="line">    <span class="comment">// we impose a memory ordering here (no-op on x86)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.1 获得本线程的Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;</span></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">    <span class="comment">//1.2 通过回收对象的stack来获取本线程的WeakOrderQueue</span></span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//2.在找不到queue的情况下，创建weakOrderQueue</span></span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//2.1 如果可以延迟回收的数量已经达到上限，则塞进去一个无用的WeakOrderQueue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">            <span class="comment">// Add a dummy queue so we know we should drop the object</span></span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.2 判断该stack是否满足条件，满足则创建新的queue对象</span></span><br><span class="line">        <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.3 将新创建的queue插入Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;线程变量里</span></span><br><span class="line">        <span class="comment">//this</span></span><br><span class="line">        delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">        <span class="comment">//发现是无用的WeakOrderQueue，则当前stack不进行回收，直接drop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">        <span class="comment">// drop object</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.4 将该回收对象加入到weakQueue中</span></span><br><span class="line">    queue.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>DELAYED_RECYCLED</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class="line">    <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释一下DELAYED_RECYCLED这个数据结构，它是一个本地线程变量，存储的key为Stack，value为WeakOrderQueue，当其他线程创建的对象被该线程回收，那么就存储创建对象的线程对应的Stack和WeakOrderQueue。</p>
<ul>
<li>例如线程1创建的对象需要线程2回收，则DELAYED_RECYCLED会存储线程2的Stack和线程2对应的WeakOrderQueue，然后加入到该queue中</li>
</ul>
<h4 id="1-获取WeakOrderQueue"><a href="#1-获取WeakOrderQueue" class="headerlink" title="1. 获取WeakOrderQueue"></a>1. 获取WeakOrderQueue</h4><p>假如线程1的对象由线程2来回收，这里DELAYED_RECYCLED.get()获取线程2的Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;，然后获取相对应的WeakOrderQueue</p>
<h4 id="2-创建WeakOrderQueue"><a href="#2-创建WeakOrderQueue" class="headerlink" title="2. 创建WeakOrderQueue"></a>2. 创建WeakOrderQueue</h4><p>2.2 判断该stack是否满足条件，满足则创建新的queue对象</p>
<p><code>WeakOrderQueue.allocate(this, thread))</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">allocate</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We allocated a Link so reserve the space</span></span><br><span class="line">    <span class="keyword">return</span> Head.reserveSpace(stack.availableSharedCapacity, LINK_CAPACITY)</span><br><span class="line">        ? newQueue(stack, thread) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Recycler#reserveSpace(Stack&lt;?&gt; stack, Thread thread)</code></p>
<p>参数：</p>
<ul>
<li>AtomicInteger availableSharedCapacity：stack目前能够允许外部线程能够缓存对象的空间大小</li>
<li>int space：所需空间大小，这里传的是<code>INK_CAPACITY</code> 默认16，需要16k大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INK_CAPACITY = safeFindNextPositivePowerOfTwo(</span><br><span class="line">        max(SystemPropertyUtil.getInt(<span class="string">"io.netty.recycler.linkCapacity"</span>, <span class="number">16</span>), <span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.2.1 判断该stack能否还能缓存space大小的对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">reserveSpace</span><span class="params">(AtomicInteger availableSharedCapacity, <span class="keyword">int</span> space)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> space &gt;= <span class="number">0</span>;</span><br><span class="line">   	<span class="comment">//cas操作更新剩余空间</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = availableSharedCapacity.get();</span><br><span class="line">        <span class="comment">//不够满足的话则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (available &lt; space) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终更新量为available - space</span></span><br><span class="line">        <span class="keyword">if</span> (availableSharedCapacity.compareAndSet(available, available - space)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建新的WeakQueue对象<code>newQueue(Stack&lt;?&gt; stack, Thread thread)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WeakOrderQueue <span class="title">newQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.2.2 创建WeakQueue对象</span></span><br><span class="line">    <span class="keyword">final</span> WeakOrderQueue queue = <span class="keyword">new</span> WeakOrderQueue(stack, thread);</span><br><span class="line">    <span class="comment">// Done outside of the constructor to ensure WeakOrderQueue.this does not escape the constructor and so</span></span><br><span class="line">    <span class="comment">// may be accessed while its still constructed.</span></span><br><span class="line">    stack.setHead(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2.2 创建WeakQueue对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeakOrderQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.2.2.1 创建一个Link节点</span></span><br><span class="line">    tail = <span class="keyword">new</span> Link();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Its important that we not store the Stack itself in the WeakOrderQueue as the Stack also is used in</span></span><br><span class="line">    <span class="comment">// the WeakHashMap as key. So just store the enclosed AtomicInteger which should allow to have the</span></span><br><span class="line">    <span class="comment">// Stack itself GCed.</span></span><br><span class="line">    <span class="comment">//2.2.2.2 创建头结节点</span></span><br><span class="line">    head = <span class="keyword">new</span> Head(stack.availableSharedCapacity);</span><br><span class="line">    <span class="comment">//2.2.2.3 将link节点跟在head节点后</span></span><br><span class="line">    head.link = tail;</span><br><span class="line">    <span class="comment">//owner拥有者字段是对回收对象创建者线程的弱引用</span></span><br><span class="line">    owner = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:%5CUsers%5C51344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200516234034054.png" alt="image-20200516234034054"></p>
<blockquote>
<ul>
<li>每一个thread对应stack，维护一个数组存储着可以复用的对象()handle)，该stack是用来存储该线程回收的对象。</li>
<li>如果该对象是由本线程1创建，但是由其他线程2回收，可以通过类常量DELAYED_RECYCLED来获取，DELAYED_RECYCLED结构是(Map&lt;Stack&lt;?&gt;,WeakQueue&gt;) ，找到或创建合适的weakQueue，将该对象回收存储在一个link节点与该WeakQueue关联，然后放入线程2的DELAYED_RECYCLED里</li>
</ul>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/hutaishi/blog/1929605/print" target="_blank" rel="noopener">Netty之Recycler实现对象池</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(7)%E2%80%94%E2%80%94ByteBuf%E7%9A%84%E9%87%8A%E6%94%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(7)%E2%80%94%E2%80%94ByteBuf%E7%9A%84%E9%87%8A%E6%94%BE/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(7)——ByteBuf的释放</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h2 id="ByteBuf的释放"><a href="#ByteBuf的释放" class="headerlink" title="ByteBuf的释放"></a>ByteBuf的释放</h2><p><code>byteBuf.release();</code> -&gt;<code>release0(int decrement)</code>，最终会走到<code>PoolByteBuf#deallocate（）</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">release0</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> oldRef = refCntUpdater.getAndAdd(<span class="keyword">this</span>, -decrement);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过去的引用值和减去的值相等，引用为0，就可以被释放了</span></span><br><span class="line">    <span class="keyword">if</span> (oldRef == decrement) &#123;</span><br><span class="line">        <span class="comment">//具体释放逻辑</span></span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldRef &lt; decrement || oldRef - decrement &gt; oldRef) &#123;</span><br><span class="line">        <span class="comment">// Ensure we don't over-release, and avoid underflow.</span></span><br><span class="line">        refCntUpdater.getAndAdd(<span class="keyword">this</span>, decrement);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalReferenceCountException(oldRef, -decrement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">        <span class="comment">//该pooledByteBuf引用地址不再指向任何一块内存</span></span><br><span class="line">        <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        memory = <span class="keyword">null</span>;</span><br><span class="line">        tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1.2.</span></span><br><span class="line">        chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//3. </span></span><br><span class="line">        recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放流程：</p>
<p><code>chunk.arena.free(chunk, handle, maxLength, cache);</code>对应下列1、2过程</p>
<p><code>recycle();</code>对应下列3过程</p>
<ol>
<li>释放的话，会把连续的内存区段加到缓存</li>
<li>如果加缓存失败，会标记连续的内存区段为未使用（page按层标记，subPage会标记位视图为0）</li>
<li>ByteBuf会加到对象池里（ByteBuf被释放后，本身这个对象也不会被销毁，加入到对象池，等到下次复用）</li>
</ol>
<h2 id="加缓存或者标记未使用"><a href="#加缓存或者标记未使用" class="headerlink" title="加缓存或者标记未使用"></a>加缓存或者标记未使用</h2><h3 id="释放内存入口"><a href="#释放内存入口" class="headerlink" title="释放内存入口"></a>释放内存入口</h3><ol>
<li><code>PoolAreana#free()</code></li>
</ol>
<p>通过<code>PoolAreana</code>创建多个<code>PoolChunk</code>，<code>PoolChunk</code>里有个属性是<code>PoolAreana</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk.unpooled) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = chunk.chunkSize();</span><br><span class="line">        destroyChunk(chunk);</span><br><span class="line">        activeBytesHuge.add(-size);</span><br><span class="line">        deallocationsHuge.increment();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.1 池化的内存才会有加入缓存复用的机制</span></span><br><span class="line">        SizeClass sizeClass = sizeClass(normCapacity);</span><br><span class="line">        <span class="comment">//1.2 添加到cache</span></span><br><span class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; cache.add(<span class="keyword">this</span>, chunk, handle, normCapacity, sizeClass)) &#123;</span><br><span class="line">            <span class="comment">// cached so not free it.</span></span><br><span class="line">            <span class="comment">//添加到cache则不释放这块内存</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 未成功添加缓存则释放</span></span><br><span class="line">        freeChunk(chunk, handle, sizeClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><ol start="2">
<li><code>cache.add(this, chunk, handle, normCapacity, sizeClass)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolArena&lt;?&gt; area, PoolChunk chunk, <span class="keyword">long</span> handle, <span class="keyword">int</span> normCapacity, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1 得到tiny/normal规格的MemoryRegionCache</span></span><br><span class="line">    MemoryRegionCache&lt;?&gt; cache = cache(area, normCapacity, sizeClass);</span><br><span class="line">    <span class="comment">// 没有cache则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 将相应的PoolChunk和handle信息添加到缓存，方便下次取出</span></span><br><span class="line">    <span class="keyword">return</span> cache.add(chunk, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1 <code>MemoryRegionCache#cache(area, normCapacity, sizeClass);</code>得到tiny规格的<code>MemoryRegionCache</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MemoryRegionCache&lt;?&gt; cacheForTiny(PoolArena&lt;?&gt; area, <span class="keyword">int</span> normCapacity) &#123;</span><br><span class="line">    <span class="comment">//2.1.1 获取subPage的idex，16则对应的idx为1</span></span><br><span class="line">    <span class="keyword">int</span> idx = PoolArena.tinyIdx(normCapacity);</span><br><span class="line">    <span class="keyword">if</span> (area.isDirect()) &#123;</span><br><span class="line">        <span class="comment">//2.1.2 通过idx从tinySubPageDirectCaches中找出对应的MemoryRegionCache</span></span><br><span class="line">        <span class="keyword">return</span> cache(tinySubPageDirectCaches, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache(tinySubPageHeapCaches, idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1.2 <code>cache(tinySubPageDirectCaches, idx);</code></p>
<p>这里<code>tinySubPageDirectCaches</code>是<code>PooledByteBufAllocator</code>创建时，创建线程本地变量<code>PoolThreadCache</code>时初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建tiny规格的MemoryRegionCache</span></span><br><span class="line"><span class="comment">* cacheSize: 单位缓存的大小，默认512字节</span></span><br><span class="line"><span class="comment">* numCaches: 创建cache数组的数量，默认32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(</span><br><span class="line">    <span class="keyword">int</span> cacheSize, <span class="keyword">int</span> numCaches, SizeClass sizeClass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheSize &gt; <span class="number">0</span> &amp;&amp; numCaches &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        MemoryRegionCache&lt;T&gt;[] cache = <span class="keyword">new</span> MemoryRegionCache[numCaches];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> maybe use cacheSize / cache.length</span></span><br><span class="line">            cache[i] = <span class="keyword">new</span> SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.2 将相应的PoolChunk和handle信息添加到缓存，方便下次取出</p>
<p><code>MemoryRegionCache#add(PoolChunk&lt;T&gt; chunk, long handle)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.2.1 创建Entry对象并添加到queue里</span></span><br><span class="line">    Entry&lt;T&gt; entry = newEntry(chunk, handle);</span><br><span class="line">    <span class="keyword">boolean</span> queued = queue.offer(entry);</span><br><span class="line">    <span class="comment">//2.2.2 如果加入queue失败</span></span><br><span class="line">    <span class="keyword">if</span> (!queued) &#123;</span><br><span class="line">        <span class="comment">// If it was not possible to cache the chunk, immediately recycle the entry</span></span><br><span class="line">        entry.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> queued;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们看看<code>PoolThreadCache$Entry</code>结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle;<span class="comment">//回收handle</span></span><br><span class="line">    PoolChunk&lt;T&gt; chunk;<span class="comment">//具体某一块内存</span></span><br><span class="line">    <span class="keyword">long</span> handle = -<span class="number">1</span>;<span class="comment">//chunk+handle：指向某一块内存的位置，handle是一个相对地址</span></span><br><span class="line"></span><br><span class="line">    Entry(Handle&lt;Entry&lt;?&gt;&gt; recyclerHandle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.recyclerHandle = recyclerHandle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        chunk = <span class="keyword">null</span>;</span><br><span class="line">        handle = -<span class="number">1</span>;</span><br><span class="line">        recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.2.1 创建Entry对象</p>
<p><code>PoolThreadCache#newEntry()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Entry <span class="title">newEntry</span><span class="params">(PoolChunk&lt;?&gt; chunk, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从对象池里取Entry，减少gc</span></span><br><span class="line">    Entry entry = RECYCLER.get();</span><br><span class="line">    entry.chunk = chunk;</span><br><span class="line">    entry.handle = handle;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加缓存失败"><a href="#添加缓存失败" class="headerlink" title="添加缓存失败"></a>添加缓存失败</h3><p>1.3 未成功添加缓存则释放</p>
<p><code>PoolArena#freeChunk(chunk, handle, sizeClass);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeChunk</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle, SizeClass sizeClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> destroyChunk;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sizeClass) &#123;</span><br><span class="line">        <span class="keyword">case</span> Normal:</span><br><span class="line">            <span class="comment">//统计normal规格的释放数量</span></span><br><span class="line">            ++deallocationsNormal;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Small:</span><br><span class="line">            ++deallocationsSmall;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tiny:</span><br><span class="line">            ++deallocationsTiny;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.3.1 根据不同的规格释放在chunk上指向的内存</span></span><br><span class="line">        destroyChunk = !chunk.parent.free(chunk, handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.3.2 通过调用UNSAFE的本地方法，清理内存</span></span><br><span class="line">    <span class="keyword">if</span> (destroyChunk) &#123;</span><br><span class="line">        <span class="comment">// destroyChunk not need to be called while holding the synchronized lock.</span></span><br><span class="line">        destroyChunk(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1.3.1  根据不同的规格释放在chunk上指向的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">free</span><span class="params">(PoolChunk&lt;T&gt; chunk, <span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">    chunk.free(handle);</span><br><span class="line">    <span class="keyword">if</span> (chunk.usage() &lt; minUsage) &#123;</span><br><span class="line">        remove(chunk);</span><br><span class="line">        <span class="comment">// Move the PoolChunk down the PoolChunkList linked-list.</span></span><br><span class="line">        <span class="keyword">return</span> move0(chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">long</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">    <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//根据handle来释放page</span></span><br><span class="line">    <span class="keyword">if</span> (bitmapIdx != <span class="number">0</span>) &#123; <span class="comment">// free a subpage</span></span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">        <span class="keyword">assert</span> subpage != <span class="keyword">null</span> &amp;&amp; subpage.doNotDestroy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line">        <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line">        <span class="comment">//找到包含头节点的PoolSubpage</span></span><br><span class="line">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="comment">//同步将这个位视图的置为0</span></span><br><span class="line">            <span class="keyword">if</span> (subpage.free(head, bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    freeBytes += runLength(memoryMapIdx);</span><br><span class="line">    setValue(memoryMapIdx, depth(memoryMapIdx));</span><br><span class="line">    updateParentsFree(memoryMapIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(6)%E2%80%94%E2%80%94subPage%E7%9A%84%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(6)%E2%80%94%E2%80%94subPage%E7%9A%84%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(6)——subPage的分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="毕业前夕提升系列-二-：Netty总结-6-——subPage的分配"><a href="#毕业前夕提升系列-二-：Netty总结-6-——subPage的分配" class="headerlink" title="毕业前夕提升系列(二)：Netty总结(6)——subPage的分配"></a>毕业前夕提升系列(二)：Netty总结(6)——subPage的分配</h2><p>前言：之前是大于一个pageSize(8k)则在一个PoolChunk(6M)里进行分配，</p>
<p>前面逻辑还是跟page级别内存分配类似：</p>
<ol>
<li>内存规格化，将需要分配的内存进行两倍化(page、subPage级别规格)</li>
<li>首先是从cache上分配</li>
<li>如果cache上无法分配的话，从poolChunkList上分配<ol>
<li>若chunk为null（首次）， chunk（初始化depth、memory数组、PoolSubpage数组）</li>
</ol>
</li>
</ol>
<h3 id="PoolSubpage数组"><a href="#PoolSubpage数组" class="headerlink" title="PoolSubpage数组"></a>PoolSubpage数组</h3><p>在<code>PoolArena</code>初始化PoolSubpage数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> numTinySubpagePools = <span class="number">512</span> &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;	</span><br><span class="line">	tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里初始化的是头部节点，会创建出32个PoolSubpage，（0B、16B、32B…）都是16的倍数（最小是16字节），数组每一个head节点后面是链接的是具体分配相对应的subPage</p>
<p><img src="C:%5CUsers%5C51344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200414213909671.png" alt="image-20200414213909671"></p>
<h3 id="subPage分配：allocateTiny"><a href="#subPage分配：allocateTiny" class="headerlink" title="subPage分配：allocateTiny"></a>subPage分配：allocateTiny</h3><ol>
<li>定位一个subPage对象</li>
<li>初始化subPage</li>
<li>PooledByteBuf初始化，拿到内存信息给pooledByteBuf进行初始化</li>
</ol>
<p>核心分配逻辑<code>PoolChunk#allocateSubpage()</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// This is need as we may add it back and so alter the linked-list structure.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 找到合适下标的PoolSubpage</span></span><br><span class="line"></span><br><span class="line">   PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配subPage是chunk一个page(8k)的子节点，所以最后一层11</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> d = maxOrder; <span class="comment">// subpages are only be allocated from pages i.e., leaves</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过memoryMap数组找到</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> id = allocateNode(d);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取PoolChunk初始化的subpage，一共2048个PoolSubPage</span></span><br><span class="line">     <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line"></span><br><span class="line">     freeBytes -= pageSize;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line"></span><br><span class="line">     PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 首次找到subPage需要将进行初始化</span></span><br><span class="line">     <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">       subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//将当前下标的</span></span><br><span class="line">       subpages[subpageIdx] = subpage;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">       subpage.init(head, normCapacity);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2. 从poolSubPage对象中分配</span></span><br><span class="line">     <span class="keyword">return</span> subpage.allocate();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-PoolSubpage的构造"><a href="#1-PoolSubpage的构造" class="headerlink" title="1. PoolSubpage的构造"></a>1. PoolSubpage的构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PoolSubpage构造函数</span></span><br><span class="line">	PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">        <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line">        <span class="keyword">this</span>.runOffset = runOffset;</span><br><span class="line">        <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">        bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">// pageSize / 16 / 64</span></span><br><span class="line">        init(head, elemSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">        doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.elemSize = elemSize;</span><br><span class="line">        <span class="keyword">if</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">            maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line">            nextAvail = <span class="number">0</span>;</span><br><span class="line">            bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                bitmapLength ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">                bitmap[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addToPool(head);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>每个chunk都会维护一个subpage列表（数量2048），存放page被切分后的子page</li>
<li>通过bimap来维护哪一个index的subpage被分配，0表示未分配，1表示已分配<ol>
<li>element代表subpage更小的单位，elementSize则表示一个element的大小，是外部传进的规格化内存分配大小（16byte*2的n次方）</li>
<li>pageSize为8k，<code>bitmap = new long[pageSize &gt;&gt;&gt; 10]; // pageSize / 16 / 64</code>，16是基础字节大小，page中element的数量是不会多于 pageSize/16个的，每个long有64位，每位便可标识一个element的使用情况。</li>
<li>init代码：例如分配16byte的空间，将page/elemSize就是把当前page切分成多少个子page（elements），bitmap是long数组，所以再除以64，就是每一个bit位来表示64个子page的分配情况。（例如分配16byte，则当前page就有512个elements）<ol>
<li><code>addToPool（head）</code>将当前创建的节点连接到head节点后</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>注：这里每个chunk（page级别）有一个subPage[2048]、之前有Arean内也有subPage[32]，区别?</p>
<p>实际上两者之间的关系可以用下面的数据结构来展示：</p>
<p><img src="C:%5CUsers%5C51344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200414213909671.png" alt="image-20200414213909671"></p>
<p>整个Chunk二叉树的最底层才可以分配，0~8k为第0个subPage、依次类推存入Chunk里的subpages数组里；而Arean的head是空的，来方便找寻后面链表中合适的subPage进行分配（找16B的则找idx为0的head节点进行分配）</p>
<h4 id="2-从poolSubPage对象中分配"><a href="#2-从poolSubPage对象中分配" class="headerlink" title="2. 从poolSubPage对象中分配"></a>2. 从poolSubPage对象中分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elemSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> toHandle(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numAvail == <span class="number">0</span> || !doNotDestroy) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1 拿到可用的bitMapIdx</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bitmapIdx = getNextAvail();</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> r = bitmapIdx &amp; <span class="number">63</span>;</span><br><span class="line">    <span class="keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    bitmap[q] |= <span class="number">1L</span> &lt;&lt; r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//numAvail为0，表示当前subPage的elments被分配完了，把当前subPage从pool中移除</span></span><br><span class="line">    <span class="keyword">if</span> (-- numAvail == <span class="number">0</span>) &#123;</span><br><span class="line">        removeFromPool();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toHandle(bitmapIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1 拿到合适的可用的bitMapIdx：<code>getNextAvail()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextAvail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获得当前subPage可用bit位下标</span></span><br><span class="line">       <span class="keyword">int</span> nextAvail = <span class="keyword">this</span>.nextAvail;</span><br><span class="line">       <span class="keyword">if</span> (nextAvail &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//当前可用bit下标是大于0的，则表明可用，赋值为不可用并返回</span></span><br><span class="line">           <span class="keyword">this</span>.nextAvail = -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">return</span> nextAvail;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果没有找</span></span><br><span class="line">       <span class="keyword">return</span> findNextAvail();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span>[] bitmap = <span class="keyword">this</span>.bitmap;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> bitmapLength = <span class="keyword">this</span>.bitmapLength;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">           <span class="keyword">long</span> bits = bitmap[i];</span><br><span class="line">           <span class="keyword">if</span> (~bits != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> findNextAvail0(i, bits);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNextAvail0</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> bits)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> maxNumElems = <span class="keyword">this</span>.maxNumElems;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> baseVal = i &lt;&lt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; j ++) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((bits &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> val = baseVal | j;</span><br><span class="line">               <span class="keyword">if</span> (val &lt; maxNumElems) &#123;</span><br><span class="line">                   <span class="keyword">return</span> val;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           bits &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>2.2 toHandle(bitmapIdx) </p>
<p>//todo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">toHandle</span><span class="params">(<span class="keyword">int</span> bitmapIdx)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0x4000000000000000L</span> | (<span class="keyword">long</span>) bitmapIdx &lt;&lt; <span class="number">32</span> | memoryMapIdx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>handle指向的是当前chunk中的唯一的一块内存（哪一个chunk的哪一个page）,通过这个long，就可以找到对应的chunk，subpage以及element的位置信息</p>
<p>handle的组成信息是由高32位bitmapIdex和低32位memoryMapIdx组成</p>
<h3 id="buf的初始化"><a href="#buf的初始化" class="headerlink" title="buf的初始化"></a>buf的初始化</h3><p>chunk上根据前面拿到的handle进行buf的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">c.initBuf(buf, handle, reqCapacity);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">initBuf</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//从handle拿到page偏移量(如果是初次分配16b：2048)</span></span><br><span class="line">        <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line">      <span class="comment">//从handle拿到bitmapIdx偏移量(bit位置)</span></span><br><span class="line">        <span class="keyword">int</span> bitmapIdx = bitmapIdx(handle);</span><br><span class="line">        <span class="keyword">if</span> (bitmapIdx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span> val = value(memoryMapIdx);</span><br><span class="line">            <span class="keyword">assert</span> val == unusable : String.valueOf(val);</span><br><span class="line">            buf.init(<span class="keyword">this</span>, handle, runOffset(memoryMapIdx) + offset, reqCapacity, runLength(memoryMapIdx),</span><br><span class="line">                     arena.parent.threadCache());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBufWithSubpage</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">long</span> handle, <span class="keyword">int</span> bitmapIdx, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> bitmapIdx != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> memoryMapIdx = memoryMapIdx(handle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到0到8k的subPage （memoryMapIdx = 2048）</span></span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</span><br><span class="line">        <span class="keyword">assert</span> subpage.doNotDestroy;</span><br><span class="line">        <span class="keyword">assert</span> reqCapacity &lt;= subpage.elemSize;</span><br><span class="line"></span><br><span class="line">        buf.init(</span><br><span class="line">            <span class="keyword">this</span>, handle,</span><br><span class="line">            runOffset(memoryMapIdx) + (bitmapIdx &amp; <span class="number">0x3FFFFFFF</span>) * subpage.elemSize + offset,</span><br><span class="line">                reqCapacity, subpage.elemSize, arena.parent.threadCache());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>注：<code>runOffset(memoryMapIdx) + (bitmapIdx &amp; 0x3FFFFFFF) * subpage.elemSize + offset</code>page偏移量加上element的bit位置的偏移量*一个element的大小加上PoolChunk的地址就是buf的地址</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wuzhenzhao/p/11304496.html" target="_blank" rel="noopener">Netty之SubPage级别的内存分配</a></p>
<p><a href="https://my.oschina.net/vqishiyu/blog/2998040" target="_blank" rel="noopener">五、netty的内存管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(12)%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(12)%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(12)——装饰者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么要使用装饰者模式"><a href="#为什么要使用装饰者模式" class="headerlink" title="为什么要使用装饰者模式"></a>为什么要使用装饰者模式</h2><p>动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案</p>
<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><ul>
<li>修饰者和被修饰者对象有相同的超类型</li>
<li>可以用一个或者多个修饰者包装一个对象</li>
<li>修饰者和被修饰者有相同超类，那么可以在任何需要原始对象（被包装的）场合，用被包装过的对象代替它。</li>
<li>装饰者可以在委托给装饰者包装的行为之前或者之后加上自己的行为，来达到特定的目的</li>
</ul>
<h2 id="netty中的修饰者模式场景"><a href="#netty中的修饰者模式场景" class="headerlink" title="netty中的修饰者模式场景"></a>netty中的修饰者模式场景</h2><ol>
<li>被修饰者</li>
</ol>
<p><code>ByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuf</span> <span class="keyword">implements</span> <span class="title">ReferenceCounted</span>, <span class="title">Comparable</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>修饰者基类</p>
<p>2.1 修饰者基类<code>WrappedByteBuf</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedByteBuf</span> <span class="keyword">extends</span> <span class="title">ByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WrappedByteBuf</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buf"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.buf = buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类继承了<code>ByteBuf</code>，是装饰者的基类，包装成员变量<code>buf</code></p>
<p>2.2 具体修饰类</p>
<p><code>SimpleLeakAwareByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLeakAwareByteBuf</span> <span class="keyword">extends</span> <span class="title">WrappedByteBuf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This object's is associated with the &#123;<span class="doctag">@link</span> ResourceLeakTracker&#125;. When &#123;<span class="doctag">@link</span> ResourceLeakTracker#close(Object)&#125;</span></span><br><span class="line"><span class="comment">     * is called this object will be used as the argument. It is also assumed that this object is used when</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ResourceLeakDetector#track(Object)&#125; is called to create &#123;<span class="doctag">@link</span> #leak&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf trackedByteBuf;</span><br><span class="line">    <span class="keyword">final</span> ResourceLeakTracker&lt;ByteBuf&gt; leak;</span><br><span class="line"></span><br><span class="line">    SimpleLeakAwareByteBuf(ByteBuf wrapped, ByteBuf trackedByteBuf, ResourceLeakTracker&lt;ByteBuf&gt; leak) &#123;</span><br><span class="line">        <span class="keyword">super</span>(wrapped);</span><br><span class="line">        <span class="keyword">this</span>.trackedByteBuf = ObjectUtil.checkNotNull(trackedByteBuf, <span class="string">"trackedByteBuf"</span>);</span><br><span class="line">        <span class="keyword">this</span>.leak = ObjectUtil.checkNotNull(leak, <span class="string">"leak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SimpleLeakAwareByteBuf(ByteBuf wrapped, ResourceLeakTracker&lt;ByteBuf&gt; leak) &#123;</span><br><span class="line">        <span class="keyword">this</span>(wrapped, wrapped, leak);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UnreleasableByteBuf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UnreleasableByteBuf</span> <span class="keyword">extends</span> <span class="title">WrappedByteBuf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SwappedByteBuf swappedBuf;</span><br><span class="line"></span><br><span class="line">    UnreleasableByteBuf(ByteBuf buf) &#123;</span><br><span class="line">        <span class="keyword">super</span>(buf <span class="keyword">instanceof</span> UnreleasableByteBuf ? buf.unwrap() : buf);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重写了release，如此进行动态扩展</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(11)%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8Netty%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(11)%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8Netty%E7%9A%84%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(11)——观察者模式在Netty的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>netty中在使用<code>writeAndFlush</code>方法最终在<code>doWrite()</code>方法，是通过NIO的socketChannel的<code>write</code>方法，该方法在设置none-blocking模式下是异步写入的，如果client需要在写入成功后加上一些后续逻辑，一般是下面做法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture = chan.writeAndFlush(object);</span><br><span class="line">channelFuture.addListener((future) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; eles &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Netty的Promise"><a href="#Netty的Promise" class="headerlink" title="Netty的Promise"></a>Netty的Promise</h2><p>netty中的Promise类就是观察者的体现，我们用<code>writeAndFlush</code>来跟踪一下源码</p>
<p><code>writeAndFlush()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAndFlush(msg, newPromise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h3><p><code>AbstractChannelHandlerContext#newPromise()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelPromise <span class="title">newPromise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel(), executor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultPromise</code>类实现了<code>Promise</code>：<code>public class DefaultPromise&lt;V&gt; extends AbstractFuture&lt;V&gt; implements Promise&lt;V&gt;</code></p>
<p><code>Promise</code>最终实现的jdk的<code>Future</code></p>
<h3 id="Promise的传递"><a href="#Promise的传递" class="headerlink" title="Promise的传递"></a>Promise的传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"msg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="comment">// cancelled</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. ctx传播，执行ctx的写入方法</span></span><br><span class="line">    write(msg, <span class="keyword">true</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>AbstractChannelHandlerContext#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            <span class="comment">//2.1 调用invokeWriteAndFlush()方法，promise代入</span></span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2 将包装好的task交付给线程池</span></span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">            <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">            <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>DefaultChannelPipeline$HeadContext#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>AbstractChannel$AbstractUnsafe#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">        <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">        <span class="comment">// will be done in flush0()</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">      </span><br><span class="line">  			<span class="comment">//2.1.2 channel已经close了，这里设置失败状态</span></span><br><span class="line">        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//2.1.3 将promise和消息一起包装成Entry对象塞到Entry链的末尾</span></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>目前promise的流动：writeAndFlush()-&gt;pipeline上-&gt;最终到HeadContext，调用unsafe的write方法写入，将将promise和消息一起包装成Entry对象塞到Entry链的末尾，随着后续的flush操作的成功与否对promise设定成功或失败</p>
<h3 id="设置失败结果"><a href="#设置失败结果" class="headerlink" title="设置失败结果"></a>设置失败结果</h3><p> 2.1.2  写入判断，如果channel已经close了，这里设置失败状态</p>
<p><code>AbstractChannel#safeSetFailure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">safeSetFailure</span><span class="params">(ChannelPromise promise, Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.1.2.1 尝试设置失败状态</span></span><br><span class="line">    <span class="keyword">if</span> (!(promise <span class="keyword">instanceof</span> VoidChannelPromise) &amp;&amp; !promise.tryFailure(cause)) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to mark a promise as failure because it's done already: &#123;&#125;"</span>, promise, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1.2.1 尝试设置失败状态</p>
<p><code>promise.tryFailure(cause)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//2.1.2.1.1 CAS设置状态</span></span><br><span class="line">    <span class="keyword">if</span> (setFailure0(cause)) &#123;</span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.1.2.1.1 CAS设置状态 <code>DefaultPromise#setValue0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果这个没有结果或者还处于未取消的结果</span></span><br><span class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</span><br><span class="line">      <span class="comment">//如果有监听者，notifyAll()</span></span><br><span class="line">        checkNotifyWaiters();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="flush过程中改变promise的结果"><a href="#flush过程中改变promise的结果" class="headerlink" title="flush过程中改变promise的结果"></a>flush过程中改变promise的结果</h3><p>当成功写完，会调用<code>ChannelOutboundBuffer#remove()</code>，其中会设置promise为SUCCESS，通知监听者，执行回调函数。</p>
<p><code>AbstractNioByteChannel$NioByteUnsafe#doWriteInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doWriteInternal</span><span class="params">(ChannelOutboundBuffer in, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">          <span class="comment">//3.1 当该buf已经写完了</span></span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">        FileRegion region = (FileRegion) msg;</span><br><span class="line">        <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> localFlushedAmount = doWriteFileRegion(region);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Should not reach here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WRITE_STATUS_SNDBUF_FULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e = flushedEntry;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clearNioBuffers();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object msg = e.msg;</span><br><span class="line"></span><br><span class="line">    ChannelPromise promise = e.promise;</span><br><span class="line">    <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"></span><br><span class="line">    removeEntry(e);</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (!e.cancelled) &#123;</span><br><span class="line">        <span class="comment">// only release message, notify and decrement if it was not canceled before.</span></span><br><span class="line">        ReferenceCountUtil.safeRelease(msg);</span><br><span class="line">        <span class="comment">//3.1 设置promise为成功</span></span><br><span class="line">        safeSuccess(promise);</span><br><span class="line">        decrementPendingOutboundBytes(size, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recycle the entry</span></span><br><span class="line">    e.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.1 设置promise为成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeSuccess</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only log if the given promise is not of type VoidChannelPromise as trySuccess(...) is expected to return</span></span><br><span class="line">    <span class="comment">// false.</span></span><br><span class="line">    PromiseNotificationUtil.trySuccess(promise, <span class="keyword">null</span>, promise <span class="keyword">instanceof</span> VoidChannelPromise ? <span class="keyword">null</span> : logger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">trySuccess</span><span class="params">(Promise&lt;? <span class="keyword">super</span> V&gt; p, V result, InternalLogger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p.trySuccess(result) &amp;&amp; logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Throwable err = p.cause();</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to mark a promise as success because it has succeeded already: &#123;&#125;"</span>, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Failed to mark a promise as success because it has failed already: &#123;&#125;, unnotified cause:"</span>,</span><br><span class="line">                    p, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>DefaultPromise#trySuccess()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//cas更改result为SUCCESS</span></span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</span><br><span class="line">      <span class="comment">//通知监听者</span></span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通知监听者"><a href="#通知监听者" class="headerlink" title="通知监听者"></a>通知监听者</h3><p><code>DefaultPromise#notifyListeners()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">final</span> InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();</span><br><span class="line">      <span class="comment">//监听者可以嵌套，nio线程最大嵌套层数为8</span></span><br><span class="line">        <span class="keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;</span><br><span class="line">            threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                notifyListenersNow();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>DefaultPromise#notifyListeners0()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners0</span><span class="params">(DefaultFutureListeners listeners)</span> </span>&#123;</span><br><span class="line">    GenericFutureListener&lt;?&gt;[] a = listeners.listeners();</span><br><span class="line">    <span class="keyword">int</span> size = listeners.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">        notifyListener0(<span class="keyword">this</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultPromise#notifyListener0()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用监听器的回调函数</span></span><br><span class="line">        l.operationComplete(future);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"An exception was thrown by "</span> + l.getClass().getName() + <span class="string">".operationComplete()"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h2><p><code>DefaultPromise#addListener()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">    checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 同步</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//2. 具体加监听器逻辑</span></span><br><span class="line">      addListener0(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3 添加监听器时，判断一次是否完成</span></span><br><span class="line">    <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">      notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>DefaultPromise#addListener0()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addListener0</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//第一次添加</span></span><br><span class="line">        listeners = listener;</span><br><span class="line">      <span class="comment">//第三次添加，直接往DefaultFutureListeners对象里的listeners数组里添加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners <span class="keyword">instanceof</span> DefaultFutureListeners) &#123;</span><br><span class="line">        ((DefaultFutureListeners) listeners).add(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//第二次添加，将listeners转成DefaultFutureListeners对象</span></span><br><span class="line">        listeners = <span class="keyword">new</span> DefaultFutureListeners((GenericFutureListener&lt;?&gt;) listeners, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>这里为什么要同步呢？</li>
</ol>
<p>监听器没有做channel和eventloop的绑定，其他的线程也可以向其注册监听器</p>
<ol start="3">
<li>添加监听器时，判断一次是否完成</li>
</ol>
<p>因为channel的操作都是NIO异步的过程，在添加监听器的时候可能已经完成了操作，所以检测一次是否完成，若执行完成，直接通知监听者</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/throwable/p/12231878.html" target="_blank" rel="noopener">从源码上理解Netty并发工具-Promise</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(10)%E2%80%94%E2%80%94Netty%E7%BC%96%E7%A0%81%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E6%AF%95%E4%B8%9A%E5%89%8D%E5%A4%95%E6%8F%90%E5%8D%87%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9ANetty%E6%80%BB%E7%BB%93(10)%E2%80%94%E2%80%94Netty%E7%BC%96%E7%A0%81%E5%99%A8/" class="post-title-link" itemprop="url">毕业前夕提升系列(二)：Netty总结(10)——Netty编码器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Netty编码器"><a href="#Netty编码器" class="headerlink" title="Netty编码器"></a>Netty编码器</h3><p>将我们业务层的对象进行encode操作，转换成byte最终写入到channel中，我们一般需要两步：</p>
<ol>
<li>实现<code>MessageToByteEncoder</code> 类<code>encode()</code>方法</li>
<li>作为<code>ChannelOutboundHandlerAdapter</code>加入到<code>ChannelPipeline</code></li>
</ol>
<h3 id="编码解密"><a href="#编码解密" class="headerlink" title="编码解密"></a>编码解密</h3><p>步骤：</p>
<ol>
<li>类型检查</li>
<li>分配内存</li>
<li>子类实现的具体编码方法</li>
<li>有可能是ByteBuf对象，会释放掉</li>
<li>传播数据</li>
</ol>
<ul>
<li>入口是重写<code>ChannelHandlerAdapter</code>的<code>write()</code>方法，当写入pipeline的数据传到该<code>ChannelOutboundHandler</code>触发调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 类型检查,是否是可以接受编码的对象</span></span><br><span class="line">        <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            I cast = (I) msg;</span><br><span class="line">            <span class="comment">//2. 分配内存</span></span><br><span class="line">            buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3. 子类实现的具体编码方法</span></span><br><span class="line">                encode(ctx, cast, buf);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//4. 释放掉</span></span><br><span class="line">                ReferenceCountUtil.release(cast);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5. 传播数据</span></span><br><span class="line">            <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                ctx.write(buf, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.release();</span><br><span class="line">                ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            buf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EncoderException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>类型检查,是否是可以接受编码的对象<code>acceptOutboundMessage(msg)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matcher.match(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>matcher</code>为<code>TypeParameterMatcher</code>接口实现对象，该接口有个match方法，来检测类型参数是否匹配。</p>
<ul>
<li><code>TypeParameterMatcher#get()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">TypeParameterMatcher</span> <span class="params">(<span class="keyword">final</span> Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; getCache =</span><br><span class="line">        InternalThreadLocalMap.get().typeParameterMatcherGetCache();</span><br><span class="line"></span><br><span class="line">    TypeParameterMatcher matcher = getCache.get(parameterType);</span><br><span class="line">    <span class="keyword">if</span> (matcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parameterType == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            matcher = NOOP;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//class自带的isInstance判断类型</span></span><br><span class="line">            matcher = <span class="keyword">new</span> ReflectiveMatcher(parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">        getCache.put(parameterType, matcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分配内存</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">allocateBuffer</span><span class="params">(ChannelHandlerContext ctx, @SuppressWarnings(<span class="string">"unused"</span>)</span> I msg,</span></span><br><span class="line"><span class="function">                               <span class="keyword">boolean</span> preferDirect) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//默认是true，分配堆外内存</span></span><br><span class="line">        <span class="keyword">if</span> (preferDirect) &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.alloc().ioBuffer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx.alloc().heapBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>传播数据</li>
</ol>
<p><code>AbstractChannelHandlerContext#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(<span class="keyword">final</span> Object msg, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"msg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="comment">// cancelled</span></span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    write(msg, <span class="keyword">false</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//5.1 找到下一个outbound的ctx</span></span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="comment">//5.2 touch：记录一下内存的写入位置</span></span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="comment">//5.3 最终调用下一个ctx重写的write</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line">            <span class="comment">// We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes</span></span><br><span class="line">            <span class="comment">// and put it back in the Recycler for re-use later.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/8343.</span></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5.3 最终调用下一个ctx重写的write()</p>
<p><code>AbstractChannelHandlerContext#invokeWrite0()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWrite0</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//最终会到head节点</span></span><br><span class="line">         ((ChannelOutboundHandler) handler()).write(<span class="keyword">this</span>, msg, promise);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         notifyOutboundHandlerException(t, promise);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><code>HeadContext#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//调用unsafe的write方法</span></span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>AbstractUnsafe$AbstractUnsafe#write()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">        <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">        <span class="comment">// will be done in flush0()</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//5.3.1 过滤掉一部分不需要的对象</span></span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.3.2 加入到缓冲队列中</span></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5.3.1 过滤掉一部分不需要的对象 <code>filterOutboundMessage</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">filterOutboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">if</span> (buf.isDirect()) &#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//5.3.1.1 进行堆内内存到堆外内存的转换</span></span><br><span class="line">        <span class="keyword">return</span> newDirectBuffer(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">        <span class="string">"unsupported message type: "</span> + StringUtil.simpleClassName(msg) + EXPECTED_TYPES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5.3.2 <code>ChannelOutboundBuffer#addMessag()</code>加入到缓冲队列中</p>
<p><code>ChannelOutboundBuffer</code>里有三个指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Entry that is the first in the linked-list structure that was flushed</span></span><br><span class="line"><span class="keyword">private</span> Entry flushedEntry;</span><br><span class="line"><span class="comment">// The Entry which is the first unflushed in the linked-list structure</span></span><br><span class="line"><span class="keyword">private</span> Entry unflushedEntry;</span><br><span class="line"><span class="comment">// The Entry which represents the tail of the buffer</span></span><br><span class="line"><span class="keyword">private</span> Entry tailEntry;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flushedEntry-&gt; unflushedEntry：表示已经flush过的Entry</p>
</li>
<li><p>unflushedEntry-&gt;tailEntry：表示没有被flush过的Entry</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMessage</span><span class="params">(Object msg, <span class="keyword">int</span> size, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//5.3.2.1 创建一个Entry对象</span></span><br><span class="line">    Entry entry = Entry.newInstance(msg, size, total(msg), promise);</span><br><span class="line">   	<span class="comment">//5.3.2.2 设置指针</span></span><br><span class="line">    <span class="comment">//如果tail指针是空的，表示第一次</span></span><br><span class="line">    <span class="keyword">if</span> (tailEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//已flush指针置为空</span></span><br><span class="line">        flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将当前尾指针指向该entry</span></span><br><span class="line">        Entry tail = tailEntry;</span><br><span class="line">        tail.next = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置为指针为当前entry</span></span><br><span class="line">    tailEntry = entry;</span><br><span class="line">    <span class="keyword">if</span> (unflushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unflushedEntry = entry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment pending bytes after adding message to the unflushed arrays.</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/1619</span></span><br><span class="line">    <span class="comment">//5.3.2.3 增加待刷新的数据大小</span></span><br><span class="line">    incrementPendingOutboundBytes(entry.pendingSize, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>incrementPendingOutboundBytes()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, size);</span><br><span class="line">    <span class="comment">//如果新要写入的buffer数据数量大于配置的高水平线</span></span><br><span class="line">    <span class="keyword">if</span> (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</span><br><span class="line">        <span class="comment">//5.3.2.3.1设置为不可写</span></span><br><span class="line">        setUnwritable(invokeLater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelOutboundBuffer#setUnwritable()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnwritable</span><span class="params">(<span class="keyword">boolean</span> invokeLater)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自旋更新成员变量unwritable</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldValue = unwritable;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newValue = oldValue | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (UNWRITABLE_UPDATER.compareAndSet(<span class="keyword">this</span>, oldValue, newValue)) &#123;</span><br><span class="line">            <span class="comment">//如果之前是可写，变成了不可写，往pipeline里</span></span><br><span class="line">            <span class="keyword">if</span> (oldValue == <span class="number">0</span> &amp;&amp; newValue != <span class="number">0</span>) &#123;</span><br><span class="line">                fireChannelWritabilityChanged(invokeLater);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="刷新队列"><a href="#刷新队列" class="headerlink" title="刷新队列"></a>刷新队列</h3><p>写入队列在上面的编码过程中描述了，最终调用了unsafe的write方法，写入到<code>ChannelOutboundBuffer</code>中。我们这里要讲一下flush的过程。</p>
<ul>
<li><code>HeadContext#flush()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unsafe#flush()</code></p>
<p>步骤：</p>
<ol>
<li>添加刷新标志并设置写状态</li>
<li>遍历buffer队列，过滤ByteBuf</li>
<li>调用jdk底层api进行自旋写</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ChannelOutboundBuffer#addFlush()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFlush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// There is no need to process all entries if there was already a flush before and no new messages</span></span><br><span class="line">    <span class="comment">// where added in the meantime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2577</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//entry获取还未进行flush操作的第一个元素</span></span><br><span class="line">    Entry entry = unflushedEntry;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (flushedEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// there is no flushedEntry yet, so start with the entry</span></span><br><span class="line">            <span class="comment">//指向第一个</span></span><br><span class="line">            flushedEntry = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flushed ++;</span><br><span class="line">            <span class="keyword">if</span> (!entry.promise.setUncancellable()) &#123;</span><br><span class="line">                <span class="comment">// Was cancelled so make sure we free up memory and notify about the freed bytes</span></span><br><span class="line">                <span class="keyword">int</span> pending = entry.cancel();</span><br><span class="line">                <span class="comment">//每flush一个对象，需要把对象的大小从总的pendsize</span></span><br><span class="line">                decrementPendingOutboundBytes(pending, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指向下一个entry</span></span><br><span class="line">            entry = entry.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (entry != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All flushed so reset unflushedEntry</span></span><br><span class="line">        unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>decrementPendingOutboundBytes()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementPendingOutboundBytes</span><span class="params">(<span class="keyword">long</span> size, <span class="keyword">boolean</span> invokeLater, <span class="keyword">boolean</span> notifyWritability)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减去pendingSize，更新TOTAL_PENDING_SIZE_UPDATER</span></span><br><span class="line">    <span class="keyword">long</span> newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(<span class="keyword">this</span>, -size);</span><br><span class="line">    <span class="comment">//当减去pendingSize后的大小小于32时(低水位),整个channel设置可写状态</span></span><br><span class="line">    <span class="keyword">if</span> (notifyWritability &amp;&amp; newWriteBufferSize &lt; channel.config().<span class="function">getWri <span class="title">teBufferLowWaterMark</span><span class="params">()</span>) </span>&#123;</span><br><span class="line">        setWritable(invokeLater);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractUnsafe#flush0()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flush0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inFlush0) &#123;</span><br><span class="line">        <span class="comment">//已经flush</span></span><br><span class="line">        <span class="comment">// Avoid re-entrance</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span> || outboundBuffer.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFlush0 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark all pending write requests as failure if the channel is inactive.</span></span><br><span class="line">    <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Do not trigger channelWritabilityChanged because the channel is closed already.</span></span><br><span class="line">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doWrite(outboundBuffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException &amp;&amp; config().isAutoClose()) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * Just call &#123;<span class="doctag">@link</span> #close(ChannelPromise, Throwable, boolean)&#125; here which will take care of</span></span><br><span class="line"><span class="comment">                     * failing all flushed messages and also ensure the actual close of the underlying transport</span></span><br><span class="line"><span class="comment">                     * will happen before the promises are notified.</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * This is needed as otherwise &#123;<span class="doctag">@link</span> #isActive()&#125; , &#123;<span class="doctag">@link</span> #isOpen()&#125; and &#123;<span class="doctag">@link</span> #isWritable()&#125;</span></span><br><span class="line"><span class="comment">                     * may still return &#123;<span class="doctag">@code</span> true&#125; even if the channel should be closed as result of the exception.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">            close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                shutdownOutput(voidPromise(), t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                close(voidPromise(), t2, FLUSH0_CLOSED_CHANNEL_EXCEPTION, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        inFlush0 = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>AbstractNioByteChannel#doWrite()</code></p>
<p><code>AbstractNioByteChannel</code>实现了<code>AbstractChannel#doWrite()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//3. 自旋写入底层</span></span><br><span class="line">    <span class="comment">//自选写次数，默认是16次</span></span><br><span class="line">    <span class="keyword">int</span> writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">   		<span class="comment">//3.1. 获取flushedEntry的entry </span></span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Wrote all messages.</span></span><br><span class="line">            <span class="comment">//如果没有要写入的数据了，取消注册到selector的OP_WRITE事件</span></span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="comment">// Directly return here so incompleteWrite(...) is not called.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.2 写入底层socket数据</span></span><br><span class="line">        writeSpinCount -= doWriteInternal(in, msg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.3 完成写过程后，对写标识的处理</span></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.2 写入底层socket数据<code>AbstractNioByteChannel#doWriteInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doWriteInternal</span><span class="params">(ChannelOutboundBuffer in, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">            <span class="comment">//writerIndex - readerIndex &gt;0 ? true: flase</span></span><br><span class="line">            <span class="keyword">if</span> (!buf.isReadable()) &#123; </span><br><span class="line">                in.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.2.1 写入底层socket传输数据，并记录下flush的数目</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">            <span class="comment">//如果写入了数据</span></span><br><span class="line">            <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//3.2.2 记录一下进度</span></span><br><span class="line">                in.progress(localFlushedAmount);</span><br><span class="line">                <span class="keyword">if</span> (!buf.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//如果发送完了，就从ChannelOutboundBuffer中</span></span><br><span class="line">                    in.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//出现写半包的情况，直接返回1，外层自旋继续写入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;</span><br><span class="line">            FileRegion region = (FileRegion) msg;</span><br><span class="line">            <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> localFlushedAmount = doWriteFileRegion(region);</span><br><span class="line">            <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                in.progress(localFlushedAmount);</span><br><span class="line">                <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                    in.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Should not reach here.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> WRITE_STATUS_SNDBUF_FULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2.1 写入底层socket传输数据，并记录下flush的数目 <code>doWriteBytes</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doWriteBytes</span><span class="params">(ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedWrittenBytes = buf.readableBytes();</span><br><span class="line">    <span class="keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会调用到<code>PooledDirectByteBuf#getBytes()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, GatheringByteChannel out, <span class="keyword">int</span> length, <span class="keyword">boolean</span> internal)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        checkIndex(index, length);</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer tmpBuf;</span><br><span class="line">        <span class="keyword">if</span> (internal) &#123;</span><br><span class="line">            tmpBuf = internalNioBuffer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpBuf = memory.duplicate();</span><br><span class="line">        &#125;</span><br><span class="line">        index = idx(index);</span><br><span class="line">        tmpBuf.clear().position(index).limit(index + length);</span><br><span class="line">        <span class="keyword">return</span> out.write(tmpBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般是<code>PooledDirectBuf</code>，最终转成nio的<code>ByteBuffer</code>，写入到jdk原生的socket channel</p>
<p>3.2.2 记录一下进度，如果已经全部写完就删除</p>
<p><code>ChannelOutboundBuffer#remove()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e = flushedEntry;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">        clearNioBuffers();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object msg = e.msg;</span><br><span class="line"></span><br><span class="line">    ChannelPromise promise = e.promise;</span><br><span class="line">    <span class="keyword">int</span> size = e.pendingSize;</span><br><span class="line"></span><br><span class="line">    removeEntry(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.cancelled) &#123;</span><br><span class="line">        <span class="comment">// only release message, notify and decrement if it was not canceled before.</span></span><br><span class="line">        ReferenceCountUtil.safeRelease(msg);</span><br><span class="line">        safeSuccess(promise);</span><br><span class="line">        decrementPendingOutboundBytes(size, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recycle the entry</span></span><br><span class="line">    e.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelOutboundBuffer#removeEntry()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeEntry</span><span class="params">(Entry e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//flushed:The number of flushed entries that are not written yet</span></span><br><span class="line">    <span class="keyword">if</span> (-- flushed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//已经没有待flush操作的entry，清空指针</span></span><br><span class="line">        <span class="comment">// processed everything</span></span><br><span class="line">        flushedEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e == tailEntry) &#123;</span><br><span class="line">            tailEntry = <span class="keyword">null</span>;</span><br><span class="line">            unflushedEntry = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flushedEntry = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.3 完成写过程后，对写标识的处理incompleteWrite()``</p>
<ul>
<li>setOpWrite：写入16次半包，仍旧没有写完数据，一般是缓冲区满了返回0（<code>out.write(tmpBuf)</code>），此时返回给外层 <code>WRITE_STATUS_SNDBUF_FULL</code>整数最大值，writeSpinCount小于0（即这里传入的setOpWrite参数有为true）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incompleteWrite</span><span class="params">(<span class="keyword">boolean</span> setOpWrite)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Did not write completely.</span></span><br><span class="line">    <span class="comment">//3.3.1 说明还没有写完，在selector上注册写标识</span></span><br><span class="line">    <span class="keyword">if</span> (setOpWrite) &#123;</span><br><span class="line">        setOpWrite();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It is possible that we have set the write OP, woken up by NIO because the socket is writable, and then</span></span><br><span class="line">        <span class="comment">// use our write quantum. In this case we no longer want to set the write OP because the socket is still</span></span><br><span class="line">        <span class="comment">// writable (as far as we know). We will find out next time we attempt to write if the socket is writable</span></span><br><span class="line">        <span class="comment">// and set the write OP if necessary.</span></span><br><span class="line">       <span class="comment">//3.3.2 写完了，清理Selector上注册的写标识。稍后再执行刷新计划</span></span><br><span class="line">        clearOpWrite();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Schedule flush again later so other tasks can be picked up in the meantime</span></span><br><span class="line">        eventLoop().execute(flushTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.3.1 说明还没有写完，在selector上注册写标识<code>AbstractNioByteChannel#setOpWrite()</code></p>
<p>继希望于selector的下次轮询，待事件循环里检查到写标志，则执行强制flush操作<code>ch.unsafe().forceFlush();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setOpWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey key = selectionKey();</span><br><span class="line">    <span class="comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span></span><br><span class="line">    <span class="comment">// from the EventLoop</span></span><br><span class="line">    <span class="comment">// See https://github.com/netty/netty/issues/2104</span></span><br><span class="line">    <span class="comment">//判断key是否还有效</span></span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">    <span class="comment">//判断Selector上是否注册了OP_WRITE标识，如果没有则注册上。</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/kubixuesheng/p/12736350.html#_label0_0" target="_blank" rel="noopener">恶劣的网络环境下，Netty是如何处理写事件的?</a></p>
<p><a href="https://www.jianshu.com/p/d82fc1c52805" target="_blank" rel="noopener">Netty 之 AbstractNioByteChannel 源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E5%A0%86%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E5%A0%86%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">堆排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-practice/" itemprop="url" rel="index"><span itemprop="name">programming practice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么叫堆"><a href="#什么叫堆" class="headerlink" title="什么叫堆"></a>什么叫堆</h2><h3 id="满二叉树、完全二叉树"><a href="#满二叉树、完全二叉树" class="headerlink" title="满二叉树、完全二叉树"></a>满二叉树、完全二叉树</h3><ul>
<li>满二叉树：一棵深度为 k，且有 2的k次方 - 1 个节点称之为满二叉树</li>
<li>完全二叉树：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树</li>
</ul>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆（二叉堆）可以视为一棵完全的二叉树，除了最底层，其他每一层都是满的。因此可以用数组来储存。<br><img src="http://p7w3aazzn.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E5%A0%86.png" alt=""></p>
<ul>
<li>Parent(i) = floor(i/2)，i 的父节点下标</li>
<li>Left(i) = 2i，i 的左子节点下标</li>
<li>Right(i) = 2i + 1，i 的右子节点下标</li>
</ul>
<h3 id="二叉堆分类"><a href="#二叉堆分类" class="headerlink" title="二叉堆分类"></a>二叉堆分类</h3><ul>
<li>最大堆：堆顶元素最大，下面的子结构的父节点元素比左右子节点元素大于或等于</li>
<li>最小堆：堆顶元素最小，下面的子结构的父节点元素比左右子节点元素小于或等于</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>思想：</p>
<ol>
<li>构成最大堆</li>
<li>取出栈顶元素</li>
<li>重新将剩下元素构成最大堆</li>
<li>反复此过程，直到最后一个元素</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><p>sort</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建最大堆</span></span><br><span class="line">    buildMaxHeep(array);</span><br><span class="line">    <span class="comment">//进行沉淀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(array, i, <span class="number">0</span>); <span class="comment">//交换最大堆顶和堆底</span></span><br><span class="line">        maxHeap(array, i, <span class="number">0</span>); <span class="comment">//重新对0-&gt;i进行最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建最大堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeep</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从中间往前开始遍历，结构稳定</span></span><br><span class="line">    <span class="keyword">int</span> half = (array.length - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeap(array, array.length, i);  <span class="comment">//递归：比较交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Q：为什么从中间开始往前调整，可以完成整个二叉堆到最大堆的工作？</strong></p>
<p>A：层数为k（深度）的一层没有子节点，不需要判断是否是满足最大堆的结构</p>
<ul>
<li>调整最大堆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> left = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> right = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> maxNode = i;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (left &lt;length&amp;&amp;array[left] &gt; array[i] ) &#123;</span><br><span class="line">         maxNode = left;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (right &lt; length&amp;&amp;array[right] &gt; array[maxNode] ) &#123;</span><br><span class="line">         maxNode = right;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (maxNode != i) &#123;</span><br><span class="line">         <span class="comment">//说明左右子节点比当前i节点大</span></span><br><span class="line">         <span class="comment">//swap</span></span><br><span class="line">         swap(array, i, maxNode);</span><br><span class="line">         maxHeap(array, length, maxNode); <span class="comment">//继续递归maxNode，跟它的下面比较</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>swap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> maxNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">    array[i] = array[maxNode];</span><br><span class="line">    array[maxNode] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">并发知识补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/concurrency/" itemprop="url" rel="index"><span itemprop="name">concurrency</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。<br>Java对象头和monitor是实现synchronized的基础。</p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h2 id="ReentrantLock与AQS"><a href="#ReentrantLock与AQS" class="headerlink" title="ReentrantLock与AQS"></a>ReentrantLock与AQS</h2><h3 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h3><ol>
<li>synchronized是一个非中断锁，当有线程需要获取已经被其他线程所占有的锁时，只能阻塞</li>
<li>性能较差，不过有偏向锁、轻量级锁，现在跟ReentrantLock差不多</li>
</ol>
<h3 id="ReentrantLock和synchronized比较"><a href="#ReentrantLock和synchronized比较" class="headerlink" title="ReentrantLock和synchronized比较"></a>ReentrantLock和synchronized比较</h3><ol>
<li>synchronized：还是有用的， 隐式获取锁和释放锁，代码简单，性能现在也跟Lock差不多。而Lock必须在finally里释放锁，不然会造成死锁</li>
<li>lock接口，多了些附加功能，可以中断，有公平和非公平两种模式，有排他和共享模式。</li>
<li>都是可重入锁</li>
<li>synchronized是在jvm层次，而Lock是jdk层次，通过CAS+自旋实现的，提供了更加细粒度的加锁功能。</li>
</ol>
<p>公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO；</p>
<p>非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</p>
<h3 id="AQS（-AbstractQueuedSynchronizer）"><a href="#AQS（-AbstractQueuedSynchronizer）" class="headerlink" title="AQS（ AbstractQueuedSynchronizer）"></a>AQS（ AbstractQueuedSynchronizer）</h3><blockquote>
<p>AQS使用一个FIFO的队列表示排队等待锁的线程,每个节点维护一个等待状态waitStatus</p>
</blockquote>
<p>AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。<br><img src="http://op7scj9he.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt=""><br>例如：ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask</p>
<h3 id="ReentrantLock结构"><a href="#ReentrantLock结构" class="headerlink" title="ReentrantLock结构"></a>ReentrantLock结构</h3><p><img src="http://op7scj9he.bkt.clouddn.com/%25F0%5BVFH_6%25%29L24%60DSO~TH%5BP.png" alt="ReentrantLock结构"></p>
<hr>
<h4 id="lock-gt-sync-lock-调用的内部sync类的lock"><a href="#lock-gt-sync-lock-调用的内部sync类的lock" class="headerlink" title="lock()-&gt;sync.lock();调用的内部sync类的lock()"></a>lock()-&gt;sync.lock();调用的内部sync类的lock()</h4><blockquote>
<p>“非公平”体现在，如果占用锁的线程刚释放锁，state置为0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。</p>
</blockquote>
<ol>
<li><p><code>compareAndSetState(0, 1)</code>，判断state是否为0（有没有其他线程占用），如果为0设置当前线程为该锁的独占线程。</p>
</li>
<li><p>如果发现该锁正在被占用，则acquire(1)(父类的)：如果此时state为0，则更改state，设置当前线程为独占线程；如果不为0，判断一下是否是当前线程占用了，如果是，更新state（可重入），不是则获取失败。</p>
</li>
<li><p>获取失败后，入队。如果尾节点不存在，需要初始化一个head节点入队列；如果尾节点存在，则通过CAS操作，判断尾节点没有发生改变，则设置当前节点为尾节点。</p>
</li>
<li><p>入队的线程不断尝试去获取获取锁，若失败就挂起（交给内核阻塞）。如果发现该节点是head节点的下一个，则可以获取锁，head节点丢弃掉（gc）。</p>
</li>
<li><p>挂起：只有前驱节点的waitState是否为SIGNAL，才能安心挂起；如果前驱节点不是SIGNAL，是CANCEL状态（取消），说明前置节点已经被放弃，通过dowhile循环，挂到SIGNAL节点下，成为它的后继，然后调用lockSupport()将自己挂起。 =&gt;无限循环获取锁</p>
</li>
</ol>
<hr>
<h4 id="unlock-gt-sync-release-1"><a href="#unlock-gt-sync-release-1" class="headerlink" title="unlock() -&gt;sync.release(1)"></a>unlock() -&gt;sync.release(1)</h4><p>流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败。这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程。</p>
<p>流程大概如下:<br><img src="http://op7scj9he.bkt.clouddn.com/912007-20170215222303613-1038407072.png" alt=""></p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><ol>
<li>读共享锁，如果存在其他线程获取写锁，则等待；允许多个读锁</li>
<li>写排他锁，如果存在其他线程获取写锁/读锁，则等待；只允许一个线程获取写锁</li>
<li>锁降级，如果当前线程获取写锁，可以获取读锁，降级</li>
</ol>
<h2 id="CountDownLatch、CyclicBarrier"><a href="#CountDownLatch、CyclicBarrier" class="headerlink" title="CountDownLatch、CyclicBarrier"></a>CountDownLatch、CyclicBarrier</h2><p><img src="http://op7scj9he.bkt.clouddn.com/BHK11J%7BVFDUB6TZNMO8GHA1.png" alt=""></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><ol>
<li>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。</li>
<li>Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，</li>
<li>如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。</li>
<li>由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</li>
</ol>
<h2 id="ThreadLocal、四种引用类型"><a href="#ThreadLocal、四种引用类型" class="headerlink" title="ThreadLocal、四种引用类型"></a>ThreadLocal、四种引用类型</h2><p>ThreadLocal：线程的局部变量，本身不存储值。通过当前线程找到ThreadLocalMap，查询ThreadLocal（key）的value<br>Thread有一个ThreadLocalMap&lt;ThreadLocal,Object&gt;,其中ThreadLocal为弱引用，如果ThreadLocal只有弱引用了，就会被gc，那么会存在&lt;null,value&gt;的Entry，value对象始终无法释放。</p>
<ol>
<li>强引用 Object obj = new Object();就算oom异常，也不会gc释放</li>
<li>软引用 内存不足时，会被gc</li>
<li>弱引用 和软引用类似，但是不管空间足不足，只存在弱引用的对象都会被gc（我想每隔一段时间就看一下某个对象里面连各个filed的值，但我还不想强引用它以免阻止他被垃圾回收。这时候你就用weakreferrence就好了哦）</li>
<li>虚引用 不影响对象的生命周期，用来跟踪对象被垃圾回收的活动，必须和引用队列联合使用，当对象要被gc前，会先放入引用队列。（程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收）</li>
</ol>
<p>为什么有这4种：在某些情况下，我们希望有些对象不需要立刻回收或者说从全局的角度来说并没有立刻回收的必要性。比如缓存系统的设计，在内存不吃紧或者说为了提高运行效率的情况下，一些暂时不用的对象仍然可放置在内存中，而不是立刻进行回收。<br>区别：体现在在被GC回收的优先级上</p>
<h2 id="Callable和、Future、FutureTask"><a href="#Callable和、Future、FutureTask" class="headerlink" title="Callable和、Future、FutureTask"></a>Callable和、Future、FutureTask</h2><ul>
<li>Callable和Runnable类似，都可以创建线程，Callable<T>里是实现call(),区别是有返回值的，可以通过Future接口里的get方法获取。</li>
<li>Thread()里只能Runnable构建，不能使用Callable<T>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;Integer&gt; future = executorService.submit(<span class="keyword">new</span> CallableTest());</span><br></pre></td></tr></table></figure></li>
<li>FutureTask实现了Future接口，可以通过callable来构建，放入Thread里，或者线程池里<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> FutureTaskTest());</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
或者<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.submit(futureTask);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="ThreadPoolExecutor线程池"><a href="#ThreadPoolExecutor线程池" class="headerlink" title="ThreadPoolExecutor线程池"></a>ThreadPoolExecutor线程池</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li>线程的创建和销毁需要消耗资源 （重复利用线程，减少创建和销毁的次数）</li>
<li>任务到来时，需要等待线程的创建。（提高响应速度）</li>
<li>如果无限制地创建，会造成系统的不稳定性。（提高线程的可管理性）</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>当一个任务提交过来到线程池，线程池的处理如下：</p>
<ol>
<li>如果正在执行任务的核心线程小于最大的核心线程数量（corePoolSize），则再创建新线程；（获取全局锁）</li>
<li>假如核心线程大于等于核心线程数量，加入BlockingQueue</li>
<li>如果BlockingQueue满了，而且没有达到线程池的最大容量（maximumPoolSize），则创建新线程执行任务（获取全局锁）</li>
<li>如果 BlockingQueue满了，但是如果创建新线程超出maximumPoolSize，任务被拒绝</li>
</ol>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul>
<li>execute():提交任务，给线程池执行</li>
<li>submit():execute+Future 相比有返回结果</li>
<li>shutdomn()：关闭线程池，等待任务执行完成，不影响</li>
<li>shutdownNow():关闭线程池，不等待任务执行完成，直接中断</li>
</ul>
<h3 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h3><ol>
<li>FixedThreadPool：创建一个指定corePoolSize的线程池，当线程池小于corePoolSize，则创建；如果大于，则放进LinkedBlockingQueue（无界队列），因此线程数不会超过corePoolSize。</li>
<li>CachedThreadPool：跟据需要创建新线程的线程池，corePoolSize为0，最大线程数为无界的，队列为SychronousQueue，主线程提交任务，如果线程池里有向队列发起poll()操作的，则发起offer()配对；如果没有空闲或者初始化时，没有线程，则创建新线程执行任务。</li>
<li>SingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务（corePoolSize为1，maximumPoolSize为1），如果这个线程异常结束，会有另一个取代它。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。反复从LinkedBlockingQueue获取任务执行。</li>
<li>ScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。</li>
</ol>
<h3 id="四个拒绝策略"><a href="#四个拒绝策略" class="headerlink" title="四个拒绝策略"></a>四个拒绝策略</h3><p>ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException<br>ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行<br>ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务<br>ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务</p>
<h4 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h4><ol>
<li>cpu密集型，就需要尽量压榨CPU，NCPU+1</li>
<li>IO密集型，2*NCPU</li>
</ol>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ol>
<li>保证可见性：可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。volatile变量进行写操作时，会加上#Lock前缀指令，当前处理器缓存行会立马写到系统内存里，使其他cpu缓存行里的缓存数据无效</li>
<li>禁止重排列，cpu和编译器会进行优化而导致指令重排列，加上内存屏障。进行写入操作时，会在写后面加上一条store指令，将本地内存中的共享变量值立即刷新到主存。在进行读操作时，会在读前面加上一条load指令，从主存中读取变量。</li>
</ol>
<blockquote>
<p>为什么重排列：CPU的主频越来越高，与cache的交互次数也越来越多，当CPU的计算速度远远超过访问cache，会产生cache wait。于是将cache进行分片，CPU可以自行选择多个闲置的分片（bank）</p>
</blockquote>
<ol start="3">
<li>不保证原子性(i++,单例 new Instance(),long double 32位会分两次操作)</li>
</ol>
<ul>
<li>为对象分配内存；</li>
<li>调用对应的构造做对象的初始化操作；（构造函数）</li>
<li>将引用instance 指向新分配的空间。<br>可能第三步移到了第二步，导致其他线程可能会得到未初始化的非null对象<br>双重校验锁：<br>解决：需要加上volatile防止重排序出错，synchronized 保证非原子性不出错</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>多线程操作共享资源时，会出现三个问题：可见性、有序性以及原子性。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁: 假设不会发生并发冲突,只有在最后更新共享资源的时候会判断一下在此期间有没有别的线程修改了这个共享资源。如果发生冲突就重试，直到没有冲突，更新成功。CAS就是一种乐观锁实现方式。</p>
<p><strong>悲观锁会阻塞其他线程。乐观锁不会阻塞其他线程，如果发生冲突，采用死循环的方式一直重试，直到更新成功。</strong></p>
<p>cas就是一种乐观锁的实现，compare and swap</p>
<blockquote>
<p>如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B,返回true。否则处理器不做任何操作，返回false。</p>
</blockquote>
<blockquote>
<p>比如当前线程比较成功后，准备更新共享变量值的时候，这个共享变量值被其他线程更改了，那么CAS函数必须返回false。</p>
</blockquote>
<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><blockquote>
<p>java中提供了Unsafe类，它提供了三个函数，分别用来操作基本类型int和long，以及引用类型Object</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSwapObject</span><br><span class="line">       (Object obj, <span class="keyword">long</span> valueOffset, Object expect, Object update);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSwapInt</span><br><span class="line">       (Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSwapLong</span><br><span class="line">      (Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">long</span> expect, <span class="keyword">long</span> update);</span><br></pre></td></tr></table></figure>
<p>参数的意义：</p>
<ol>
<li>obj 和 valueOffset：表示这个共享变量的内存地址。这个共享变量是obj对象的一个成员属性，valueOffset表示这个共享变量在obj类中的内存偏移量。所以通过这两个参数就可以直接在内存中修改和读取共享变量值。</li>
<li>expect: 表示预期原来的值。</li>
<li>update: 表示期待更新的值。</li>
</ol>
<h3 id="getAndAddInt"><a href="#getAndAddInt" class="headerlink" title="getAndAddInt"></a>getAndAddInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">int</span> <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect;</span><br><span class="line">        <span class="comment">// 利用循环，直到更新成功才跳出循环。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取value的最新值</span></span><br><span class="line">            expect = <span class="keyword">this</span>.getIntVolatile(obj, valueOffset);</span><br><span class="line">            <span class="comment">// expect + var表示需要更新的值，如果compareAndSwapInt返回false，说明value值被其他线程更改了。</span></span><br><span class="line">            <span class="comment">// 那么就循环重试，再次获取value最新值expect，然后再计算需要更新的值expect + var。直到更新成功</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(obj, valueOffset, expect, expect + <span class="keyword">var</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程在更改value成功后的，value变量原先值。并不是更改后的值</span></span><br><span class="line">        <span class="keyword">return</span> expect;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>i++，自增的过程包含了读改写，非原子操作。在改的过程时， 其他cpu也许会更改共享变量的值，这时需要CAS操作来试探是否更改，如果发现更改，那么当前i+1 并非我们希望set的值，需要重新计算…</p>
<h3 id="AtomicInteger类"><a href="#AtomicInteger类" class="headerlink" title="AtomicInteger类"></a>AtomicInteger类</h3><ol>
<li>成员变量和静态代码块<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; <span class="comment">// 使用volatile修饰，解决了可见性和有序性问题。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>value为AtomicInteger对象的值</li>
<li>valueOffset为value在对象内存空间的偏移</li>
<li>unsafe 一些native方法，通过它实现CAS操作，因为共享变量是int类型，所以调用compareAndSwapInt方法。</li>
</ul>
<blockquote>
<p>value是一个volatile变量，在内存中可见，任何线程都不允许对其进行拷贝，因此JVM可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
</blockquote>
<p>static中<code>valueOffset=unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(&quot;value&quot;));</code><br>通过unsafe 获取valueOffset（对象内存偏移量）</p>
<ol start="2">
<li><p>get/set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接读取。因为是volatile关键子修饰的，总是能看到(任意线程)对这个volatile变量最新的写入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接写入。因为是volatile关键子修饰的，所以它修改value变量也会立即被别的线程读取到。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compareAndSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>如果value变量的当前值(内存值)等于期望值(expect)，那么就把update赋值给value变量，返回true。</li>
<li>如果value变量的当前值(内存值)不等于期望值(expect)，就什么都不做，返回false。</li>
<li>这个就是CAS操作，使用unsafe.compareAndSwapInt方法，保证整个操作过程的原子性</li>
</ul>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p>
<ul>
<li>内存地址（c++）<br>线程 1 从内存位置V中取出A，A指向内存位置W。<br>线程 2 从位置V中取出A。<br>线程 2 进行了一些操作，释放了A指向的内存。<br>线程 2 重新申请内存，并恰好申请了内存位置W，将位置W存入C的内容。<br>线程 2 将内存位置W写入位置V。<br>线程 1 进行CAS操作，发现位置V中仍然是A指向的即内存位置W，操作成功</li>
</ul>
<p><strong>内存管理机制中广泛使用的内存重用机制，发现内存地址还是那个旧的指针变量，跟期待的值一样，则CAS操作成功，但实际指针变量的所指向内存空间里的值发生了改变</strong></p>
<ul>
<li>普通数据<br>进程P1读取了一个数值A<br>P1被挂起(时间片耗尽、中断等)，进程P2开始执行<br>P2修改数值A为数值B，然后又修改回A<br>P1被唤醒，比较后发现数值A没有变化，程序继续执行。</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>对于内存重用机制导致ABA问题，java的垃圾回收机制帮我们解决了；<br>而第二个问题，加入版本号即可解决</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol>
<li>capacity:HashMap中桶的数量。默认值为16</li>
<li>transient int size;HashMap中存放KV的数量（为链表和树中的KV的总和）</li>
<li>int threshold; 如果当前size超过threshold，会调用resize方法（capacity * load factor）</li>
</ol>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><ol>
<li>首先检测table是否为空，为空则创建一个数组</li>
<li>判断key是否为null。若为null，特殊处理，创建一个（key为null）hash值为0的k-v对</li>
<li>算出key所对应的hash值，找出数组中对应的下标i</li>
<li>遍历table[i]是否存在相同的键值，如果相同则覆盖，返回一个老value值</li>
<li>如果没有一样的，调用addEntry()，判断在插入之前的size是否超过threshold，如果超过就调用resize()扩容两倍的长度,注意扩容的顺序，扩容之前old1-&gt;old2-&gt;old3，扩容之后old3-&gt;old2-&gt;old1</li>
<li>如果扩容了，因为数组的长度变了，需要重新计算下标。</li>
<li>插入：注意插入的顺序，原先table[index]的链表比如 old1-&gt;old2-&gt;old3，插入新值之后为new1-&gt;old1-&gt;old2-&gt;old3.</li>
</ol>
<p><strong>1.7之前是头插法，1.8之后是尾插法</strong>。因为1.8是数组+ 链表+红黑树（table[i]超过8个），效率变高，之前头插法是因为如果链表接了10000个，尾插法遍历太多。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ol>
<li>如果key为null，则在table[0]寻找</li>
<li>否则计算key对应的hash，找到在table表中的下标</li>
<li>遍历table[i]的链表，通过hash和equals找到Entry</li>
<li>得到entry中的value</li>
</ol>
<h3 id="多线程为什么导致死循环"><a href="#多线程为什么导致死循环" class="headerlink" title="多线程为什么导致死循环"></a>多线程为什么导致死循环</h3><ol>
<li>size超过当前最大容量*负载因子时候会发生resize</li>
<li>两个线程同时执行了resize的方法（transfer()），在各自内部线程的栈里都生成了局部的table。<br>比如：</li>
<li>扩容前 table[i] - &gt;3 - &gt; 7 - &gt; null</li>
<li>需要扩容了，transfer方法：<ul>
<li>线程1： e指向3,nexr指向7 暂时挂起</li>
<li>线程2：完成扩容，table[j] = 7 -&gt; 3 - &gt; null</li>
</ul>
</li>
<li>线程1获取时间片，继续执行循环，这时把table[j] - &gt;3 -&gt; null，此时e指向7，next指向3；<br>然后继续插入，table[j] -&gt; 7 -&gt; 3 - &gt;null，但是此时7的next已经是3，不是null了，则继续循环3；<br>e指向3，next为null；循环之后，3指向7；<br>互相指向，以后一旦执行到遍历next操作，会死循环，cpu占用率到100%</li>
</ol>
<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本</p>
<h3 id="hash算法-：-h-amp-length-1"><a href="#hash算法-：-h-amp-length-1" class="headerlink" title="hash算法 ： h &amp; (length-1)"></a>hash算法 ： h &amp; (length-1)</h3><p>最常见的取hash算法是value mod length，而这里用的是‘&amp;’运算<br>分析：HashMap的capacity都是2的幂，length-1转换成二进制就全是1，例如（16的容量，length-1就为1111），这样&amp;运算的话，参与运算的另一个成员的每位是什么，运算结果就是什么。假设与hash值参与运算的某一位为0，那么不管hash的对应的那一位是什么，对应的运算结果位都为0，造成hash冲突。<br><strong>&amp;运算的好处</strong></p>
<ol>
<li>length（2的整数次幂）的特殊性导致了length-1的特殊性（二进制全为1）</li>
<li>位运算快于十进制运算，hashmap扩容也是按位扩容，所以相比较就选择了后者</li>
</ol>
<h3 id="如何解决hash冲突"><a href="#如何解决hash冲突" class="headerlink" title="如何解决hash冲突"></a>如何解决hash冲突</h3><ol>
<li>哈希表：散列表（Hashtable，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</li>
<li>哈希冲突：对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为哈希冲突。<br>解决hash冲突的方法：<br>（1）开放定址法（线性探测再散列，线性补偿探测法，伪随机探测）：这种方法也称再散列    法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产    生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，    直到找出一个不冲突的哈希地址pi。<br>（2）再哈希法：就是算hashcode的方法不止一个，一个要是算出来重复啦，再用另一个算    法    去算，直到冲突不再发生为止。<br>（3）链地址法(Javahashmap就是这么做的)：这种方法的基本思想是将所有哈希地址为i的    元    素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，    因    而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。<br>（4）建立一个公共溢出区：将哈希表分为基本表和溢出表两个部分，凡是和基本表发生冲突    的元素，一律填入溢出表。</li>
</ol>
<h3 id="ConcurrentHashMap：分段锁"><a href="#ConcurrentHashMap：分段锁" class="headerlink" title="ConcurrentHashMap：分段锁"></a>ConcurrentHashMap：分段锁</h3><p>结构：Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>1.因竞争资源发生死锁 现象：系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象 2.进程推进顺序不当发生死锁</p>
<h3 id="死锁的四个必要条件："><a href="#死锁的四个必要条件：" class="headerlink" title="死锁的四个必要条件："></a>死锁的四个必要条件：</h3><ol>
<li><p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</p>
</li>
<li><p>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</p>
</li>
<li><p>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
</li>
<li><p>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</p>
</li>
</ol>
<h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>有两个容器，一个用于保存线程正在请求的锁，一个用于保存线程已经持有的锁。每次加锁之前都会做如下检测:</p>
<ol>
<li>检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来</li>
<li>遍历第一步中返回的线程，检查自己持有的锁是否正被其中任何一个线程请求，如果第二步返回真,表示出现了死锁</li>
</ol>
<h3 id="死锁的预防："><a href="#死锁的预防：" class="headerlink" title="死锁的预防："></a>死锁的预防：</h3><ol>
<li>破坏互斥条件：如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本          不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁          的方法不太可行，而且在有的场合应该保护这种互斥性。</li>
<li>破坏请求和保持条件：釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资          源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它          所有，也不再提出其他资源请求，</li>
<li>破坏剥夺条件：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它          必须释放已经保持的所有资源，待以后需要时再重新申请。</li>
<li>破坏环路等待条件：为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编          号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。</li>
</ol>
<h3 id="死锁的避免："><a href="#死锁的避免：" class="headerlink" title="死锁的避免："></a>死锁的避免：</h3><p>（1）安全序列：避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，    应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配    给进程，否则让进程等待。所谓安全状态，是指系统能按某种进程推进顺序( P1，P2，…，    Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都    可顺序地完成。此时称P1，P2，…，Pn为安全序列。如果系统无法找到一个安全序列，则    称系统处于不安全状态。<br>（2）银行家算法：银行家算法是最著名的死锁避免算法。它提出的思想是：把操作系统看做是    银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当    于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资    源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则    按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进    程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超    过则拒绝分配资源，若没有超过则再测试系统现存的资源能否    满足该进程尚需的最大资源    量，若能满足则按当前申请量分配资源，否则也要推迟分配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257900554.cos.ap-beijing.myqcloud.com/100807cd4jj1cfzf7jkjkj.jpg">
      <meta itemprop="name" content="lqsss">
      <meta itemprop="description" content="There's no place like 127.0.0.1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lqsss's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB/" class="post-title-link" itemprop="url">内部类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-02 18:35:38" itemprop="dateCreated datePublished" datetime="2020-08-02T18:35:38+08:00">2020-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/grammar/" itemprop="url" rel="index"><span itemprop="name">grammar</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><ol>
<li>完善多重继承</li>
<li>闭包与回调</li>
</ol>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h3><ol>
<li>因为某个功能或者属性而继承许多不必要的东西</li>
<li>继承的多个父类，可能出现同名方法或者属性，此时就会有歧义</li>
</ol>
<h3 id="内部类实现多继承"><a href="#内部类实现多继承" class="headerlink" title="内部类实现多继承"></a>内部类实现多继承</h3><p>虽然C++的多继承一直被诟病，但有时是真的需要多继承来完成，Java中可以通过实现多个接口或者内部类来模拟多继承</p>
<ul>
<li><p>Eraser抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Eraser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Pencil抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pencil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wirte</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PencilWithEraser子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> innerClass.meaning.mutiExtends;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lqs on 2018/5/9.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PencilWithEraser</span> <span class="keyword">extends</span> <span class="title">Pencil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyEraser eraser = <span class="keyword">new</span> MyEraser();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"use to write"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承了橡皮擦的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEraser</span> <span class="keyword">extends</span> <span class="title">Eraser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            PencilWithEraser.<span class="keyword">this</span>.eraser();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eraser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"use to erase"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Eraser <span class="title">getEraser</span><span class="params">()</span></span>&#123; <span class="comment">//这里返回父类抽象类类型，因为内部类(子类)是private,外部无法访问里面的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyEraser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PencilWithEraser pencilWithEraser = <span class="keyword">new</span> PencilWithEraser();</span><br><span class="line">        pencilWithEraser.work();<span class="comment">//write</span></span><br><span class="line">        pencilWithEraser.getEraser().work();<span class="comment">//eraser</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="闭包和回调"><a href="#闭包和回调" class="headerlink" title="闭包和回调"></a>闭包和回调</h2><h3 id="什么叫闭包"><a href="#什么叫闭包" class="headerlink" title="什么叫闭包"></a>什么叫闭包</h3><p>闭包这个概念我第一次是在js这种动态语言获知的，很多语言都有闭包，简短的话来说，一个持有外部环境变量的函数就是闭包</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>就不多解释了,A提供API给B调用，有时需要A在特定条件和时机调用B的方法。</p>
<blockquote>
<p>一般使用一个库或类时，是你主动调用人家的API，这个叫Call，有的时候这样不能满足需要，需要你注册（注入）你自己的程序（比如一个对象)，然后让人家在合适的时候来调用你，这叫Callback。</p>
</blockquote>
<ul>
<li><p>主体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Very simple to just implement the interface</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Other operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123;</span><br><span class="line">        mi.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="comment">//既想实现接口又想继承，然而接口和父类都有相同名称的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部类实现接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实现方法在外部类里</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you'd get an infinite recursion</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个内部类的引用</span></span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有回调的引用</span></span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 = <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        System.out.println(<span class="string">"caller2"</span>);</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>内部类是面向对象的闭包，因为它不仅包含创建内部类的作用域的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class=partial"site-overview-wrap sidebar-panel">
        [object Object]
            <div id="music163player">
              <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=517346741&auto=1&height=66"></iframe>
            </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lqsss</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
